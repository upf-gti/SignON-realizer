import * as THREE  from 'three';
// @BehaviourManager// Message gets to BehaviourManager -> then to facial control -> then to BehaviorRealizer// Needs to synchronize BML actions of the same block// [MERGE,APPEND,REPLACE,OVERWRITE]// Warnings and feedback// wait, synchronize, constraints, before, afterfunction BehaviourManager() {	// BML instruction keys	this.bmlKeys = ["blink", "gaze", "gazeShift", "face", "faceShift", "head", "headDirectonShift", "lg", "gesture", "posture", "animation"];	// BML stack	this.blinkStack = [];	this.gazeStack = [];	this.faceStack = [];	this.headStack = [];	this.headDirStack = [];	this.speechStack = [];	this.gestureStack = [];	this.pointingStack = [];	this.postureStack = [];	this.lgStack = [];	this.animationStack = [];	this.BMLStacks = [ this.blinkStack, this.gazeStack, this.faceStack, this.headStack, this.headDirStack, this.speechStack, this.lgStack,	this.gestureStack, this.pointingStack, this.postureStack, this.animationStack ];	// Block stack	this.stack = [];}BehaviourManager.prototype.reset = function (){	// reset stacks	this.blinkStack.length = 0	this.gazeStack.length = 0;	this.faceStack.length = 0;	this.headStack.length = 0;	this.headDirStack.length = 0;	this.speechStack.length = 0;	this.gestureStack.length = 0;	this.pointingStack.length = 0;	this.postureStack.length = 0;	this.lgStack.length = 0;	this.animationStack.length = 0;	this.stack.length = 0;}// TODO: PROVIDE FEEDBACK AND WARNINGS// BehaviourManager.prototype.update = function (actionCallback, time) {// 	// Time now// 	this.time = time;// 	// Several blocks can be active (MERGE composition)// 	for (let i = 0; i < this.stack.length; i++) {// 		// If it is not active// 		if (!this.stack[i].isActive) {// 			// Block starts// 			if (this.stack[i].startGlobalTime <= this.time) {// 				this.stack[i].isActive = true;// 			}// 		}// 		// Check if has ended// 		if ( this.stack[i].isActive ) {// 			if (this.stack[i].endGlobalTime <= this.time) {// 				this.stack[i].isActive = false;// 				// Remove// 				this.removeFromStacks(this.stack[i]);// 				this.stack.splice(i, 1);// 				i--;// 			}// 		}// 	}	// 	// Check active BML and blocks (from BMLStacks)// 	for (let i = 0; i < this.BMLStacks.length; i++) {// 		// Select bml instructions stack// 		let stack = this.BMLStacks[i];// 		for (let j = 0; j < stack.length; j++) {// 			let bml = stack[j];// 			// BML is not active// 			if ( !bml.isActive ) {// 				// Set BML to active// 				if (bml.startGlobalTime <= this.time) {// 					bml.isActive = true;// 					actionCallback(bml.key, bml); // CALL BML INSTRUCTION// 				}// 			}// 			// BML has finished// 			else if (bml.isActive) {// 				if (bml.endGlobalTime <= this.time) {// 					bml.isActive = undefined;// 					// Remove from bml stack// 					stack.splice(j, 1);// 					j--;// 				}// 			}// 		}// 	}// }// V2 update: stacks will only contain blocks/bmls that have not started yetBehaviourManager.prototype.update = function (actionCallback, time) {	// Time now	this.time = time;	// Several blocks can be active (MERGE composition)	for (let i = 0; i < this.stack.length; i++) {		// If it is not active		if (!this.stack[i].isActive) {			// Block starts            if (this.stack[i].startGlobalTime <= this.time) {				this.stack.splice(i, 1);				i--;			}		}	}		// Check active BML and blocks (from BMLStacks)	for (let i = 0; i < this.BMLStacks.length; i++) {		// Select bml instructions stack		let stack = this.BMLStacks[i];		for (let j = 0; j < stack.length; j++) {			let bml = stack[j];			// Set BML to active			if (bml.startGlobalTime <= this.time) {				actionCallback(bml.key, bml); // CALL BML INSTRUCTION				stack.splice(j, 1);				j--;			}		}	}}BehaviourManager.prototype.newBlock = function (block, time) {	if (!block) {		return;	}	// Time now	if (time == 0) {		time = 0.001;	}	this.time = time;	// TODO: require	// Fix and Sychronize (set missing timings) (should substitute "start:gaze1:end + 1.1" by a number)	this.fixBlock(block);	// Remove blocks with no content	if (block.end == 0) {		//console.error("Refused block.\n", JSON.stringify(block));		return;	}	// Add to stack	this.addToStack(block);}BehaviourManager.prototype.fixBlock = function (block) {	// Define block start (in BML this is not specified, only in bml instructions, not in blocks)	//block.start = block.start || 0.0;	// Check if it is a number	block.start = isNaN(block.start) ? 0 : block.start;	// Define timings and find sync attributes (defaults in percentage unless start and end)	// Blink	if (block.blink)		block.blink = this.fixBML(block.blink, "blink", block, { start: 0, attackPeak: 0.25, relax: 0.25, end: 0.5 });	// Gaze	if (block.gaze)		block.gaze = this.fixBML(block.gaze, "gaze", block, { start: 0, ready: 0.33, relax: 0.66, end: 2.0 });	// GazeShift	if (block.gazeShift)		block.gazeShift = this.fixBML(block.gazeShift, "gazeShift", block, { start: 0, end: 2.0 });	// Head	if (block.head)		block.head = this.fixBML(block.head, "head", block, { start: 0, ready: 0.15, strokeStart: 0.15, stroke: 0.5, strokeEnd: 0.8, relax: 0.8, end: 2.0 });	// HeadDirection	if (block.headDirectionShift)		block.headDirectionShift = this.fixBML(block.headDirectionShift, "headDirectionShift", block, { start: 0, end: 2.0 });	// Face	if (block.face)		block.face = this.fixBML(block.face, "face", block, { start: 0, attackPeak: 0.4, relax: 0.6, end: 1 });	// Face	if (block.faceFACS)		block.faceFACS = this.fixBML(block.faceFACS, "faceFACS", block, { start: 0, attackPeak: 0.4, relax: 0.6, end: 1 });	// Face	if (block.faceLexeme)		block.faceLexeme = this.fixBML(block.faceLexeme, "faceLexeme", block, { start: 0, attackPeak: 0.4, relax: 0.6, end: 1 });	// Face	if (block.faceEmotion)		block.face = this.fixBML(block.faceEmotion, "face", block, { start: 0, attackPeak: 0.4, relax: 0.6, end: 1 });	// Face VA	if (block.faceVA)		block.face = this.fixBML(block.faceVA, "face", block, { start: 0, attackPeak: 0.4, relax: 0.6, end: 1 });	// FaceShift	if (block.faceShift)		block.faceShift = this.fixBML(block.faceShift, "faceShift", block, { start: 0, end: 1 });	// Speech (several instructions not implemented)	if (block.speech)		block.speech = this.fixBML(block.speech, "speech", block, { start: 0, end: 2.5 });	// Language-generation	if (block.lg)		block.lg = this.fixBML(block.lg, "lg", block, { start: 0, end: 1 });	// Posture	if (block.posture)		block.posture = this.fixBML(block.posture, "posture", block, { start: 0, ready: 0.3, strokeStart: 0.3, stroke: 0.4, strokeEnd: 0.6, relax: 0.7, end: 1.0 });	// Gesture	if (block.gesture)		block.gesture = this.fixBML(block.gesture, "gesture", block, { start: 0, ready: 0.1, strokeStart: 0.2, stroke: 0.7, strokeEnd: 0.7, relax: 1.4, end: 1.5 });	// Pointing	if (block.pointing)		block.pointing = this.fixBML(block.pointing, "pointing", block, { start: 0, ready: 0.3, strokeStart: 0.3, stroke: 0.4, strokeEnd: 0.6, relax: 0.7, end: 1.0 });	// Animation	if (block.animation)		block.animation = this.fixBML(block.animation, "animation", block, { start: 0, end: 2.0 });	// Find end of block	block.end = this.findEndOfBlock(block);}BehaviourManager.prototype.fixBML = function (bml, key, block, sync) {	// Error check	if (!bml) {		console.warn("BML instruction undefined or null:", key, bml);		delete block[key];		return;	}	// Several instructions inside	if (bml.constructor === Array) {		for (var i = 0; i < bml.length; i++)			bml[i] = this.fixBML(bml[i], key, block, sync);		return bml;	}	// Check if is it an object	if (typeof bml !== "object" || bml === null)		bml = {};	// Define type (key)	bml.key = key;	// Define timings	// START	bml.start = isNaN(bml.start) ? 0.0 : bml.start;	if (bml.start < 0) {		bml.start = 0;	}	// END	bml.end = isNaN(bml.end) ? (bml.start + sync.end) : bml.end;	return bml;}BehaviourManager.prototype.findEndOfBlock = function (block) {	let keys = Object.keys(block);	let latestEnd = 0;	for (let i = 0; i < keys.length; i++) {		let bml = block[keys[i]];		if (bml === null || bml === undefined) { continue; }		else if ( !isNaN( bml.end ) ) // bml is just an instruction			latestEnd = Math.max(bml.end, latestEnd);		else if (bml.constructor === Array){ // several instructions inside class			for (let j = 0; j < bml.length; j++) {				if (bml[j] && !isNaN( bml[j].end ) )					latestEnd = Math.max(bml[j].end, latestEnd);			}		}	}	return latestEnd;}BehaviourManager.prototype.addToStack = function (block) {	// block composition defined in bml standard [MERGE, REPLACE, APPEND]. OVERWRITE is not included	if (Object.prototype.toString.call(block.composition) === '[object String]')		block.composition = block.composition.toUpperCase();		if (this.stack.length == 0) {		block.startGlobalTime = this.time + block.start;		block.endGlobalTime = this.time + block.end;		this.stack.push( block );	}	// OVERWRITE	else if (block.composition == "OVERWRITE") { // Doens't make sense, only for individual stacks, not whole		// Substitute in stack		block.startGlobalTime = this.time + block.start;		block.endGlobalTime = this.time + block.end;		let last = this.stack[this.stack.length - 1];		if (block.endGlobalTime < last.endGlobalTime) {			this.stack[this.stack.length - 1] = block;			this.stack.push(last);		}		else			this.stack.push(block);				// Add to bml stack (called at the end of function)	}	// APPEND	else if (block.composition == "APPEND") {		//The start time of the new block will be as soon as possible after the end time of all prior blocks.		block.startGlobalTime = this.stack[this.stack.length - 1].endGlobalTime + block.start;		block.endGlobalTime = this.stack[this.stack.length - 1].endGlobalTime + block.end;		this.stack.push(block);	}	// REPLACE	else if (block.composition == "REPLACE") {		//The start time of the new block will be as soon as possible. The new block will completely replace all prior bml blocks. All behavior specified in earlier blocks will be ended and the ECA will revert to a neutral state before the new block starts.		// Second action in the stack (if start != 0 waiting time?)		block.startGlobalTime = (this.stack[0].isActive) ? this.stack[0].endGlobalTime : this.time;		block.endGlobalTime = block.startGlobalTime + block.end;		// Remove following blocks		for (let i = (this.stack[0].isActive) ? 1: 0; i < this.stack.length; i++)			this.removeFromStacks(this.stack[i]);		this.stack.push( block );	}	// MERGE (default)	else {		// Add to block stack		block.startGlobalTime = this.time + block.start;		block.endGlobalTime = this.time + block.end;		this.stack.push(block);		// bubble sort. Lowest endGlobalTimes should be first, Biggest endGlobalTime should be the last		if ( this.stack.length > 1 ){			for ( let i = this.stack.length-2; i >= 0; --i ){				let prev = this.stack[i];				if ( prev.endGlobalTime > block.endGlobalTime ){					this.stack[i] = block;					this.stack[i+1] = prev;				}				else{ break; }			}		}			}	// Add to stacks	this.addToBMLStacks(block);}// Removes all bml instructions from stacksBehaviourManager.prototype.removeFromStacks = function (block) {	// Add delete variable in block to bml instructions	let keys = Object.keys(block);	for (let i = 0; i < keys.length; i++) { // Through bml instructions		let bml = block[keys[i]];		if (bml !== null || bml !== undefined) {			if (typeof bml === "object"){ // bml is an instruction				bml.del = true;			}			else if (bml.constructor === Array){ // bml is an array of bml instructions				for (let j = 0; j < bml.length; j++){					bml[j].del = true;				}			}		}	}	// Remove from each stack all bml with del	for (let i = 0; i < this.BMLStacks.length; i++) { // Through list of stacks		for (let j = 0; j < this.BMLStacks[i].length; j++) {// Through stack			if (this.BMLStacks[i][j].del) { // Find del variable in stack				this.BMLStacks[i][j].isActive = undefined; // If reusing object				this.BMLStacks[i].splice(j, 1); // Remove from stack				j--;			}		}	}}// Add bml actions to stacks with global timingsBehaviourManager.prototype.addToBMLStacks = function (block) {	let globalStart = block.startGlobalTime;	// Blink	if (block.blink)		this.processIntoBMLStack(block.blink, this.blinkStack, globalStart, block.composition);	// Gaze	if (block.gaze)		this.processIntoBMLStack(block.gaze, this.gazeStack, globalStart, block.composition);	if (block.gazeShift)		this.processIntoBMLStack(block.gazeShift, this.gazeStack, globalStart, block.composition);	// Head	if (block.head)		this.processIntoBMLStack(block.head, this.headStack, globalStart, block.composition);	if (block.headDirectionShift)		this.processIntoBMLStack(block.headDirectionShift, this.headDirStack, globalStart, block.composition);	// Face	if (block.faceLexeme)		this.processIntoBMLStack(block.faceLexeme, this.faceStack, globalStart, block.composition);	if (block.faceFACS)		this.processIntoBMLStack(block.faceFACS, this.faceStack, globalStart, block.composition);	if (block.face)		this.processIntoBMLStack(block.face, this.faceStack, globalStart, block.composition);	if (block.faceShift)		this.processIntoBMLStack(block.faceShift, this.faceStack, globalStart, block.composition);	// Speech	if (block.speech)		this.processIntoBMLStack(block.speech, this.speechStack, globalStart, block.composition);	// Posture	if (block.posture)		this.processIntoBMLStack(block.posture, this.postureStack, globalStart, block.composition);	// Gesture	if (block.gesture)		this.processIntoBMLStack(block.gesture, this.gestureStack, globalStart, block.composition);	// Pointing	if (block.pointing)		this.processIntoBMLStack(block.pointing, this.pointingStack, globalStart, block.composition);	// LG	if (block.lg)		this.processIntoBMLStack(block.lg, this.lgStack, globalStart, block.composition);	// Animation	if (block.animation)		this.processIntoBMLStack(block.animation, this.animationStack, globalStart, block.composition);}// Add bml action to stackBehaviourManager.prototype.processIntoBMLStack = function (bml, stack, globalStart, composition) {	// Several instructions	if (bml.constructor === Array) {		for (let i = 0; i < bml.length; i++)			this.processIntoBMLStack(bml[i], stack, globalStart, composition);		return;	}	let merged = this.mergeBML(bml,stack,globalStart,  composition); 	bml.del = !merged;	// First, we check if the block fits between other blocks, thus all bml instructions	// should fit in the stack.	if (!merged)		console.warn("Could not add to " + bml.key + " stack. \n");// + "BML: ", }BehaviourManager.prototype.mergeBML = function(bml, stack, globalStart, composition){	let merged = false;		// Refs to another block (negative global timestamp)	if (bml.start < 0)		bml.start = (-bml.start) - globalStart; // The ref timestamp should be always bigger than globalStart	if (bml.end < 0)		bml.end = (-bml.end) - globalStart;	bml.startGlobalTime = globalStart + bml.start;	bml.endGlobalTime = globalStart + bml.end;	// Check errors	if (bml.start < 0) console.error("BML start is negative", bml.start, bml.key, globalStart);	if (bml.end < 0) console.error("BML end is negative", bml.end, bml.key, globalStart);	// Now change all attributes from timestamps to offsets with respect to startGlobalTime		// Modify all sync attributes to remove non-zero starts (offsets)	// Also fix refs to another block (negative global timestamp)	bml.end -= bml.start;	if ( !isNaN(bml.attackPeak) ) 		bml.attackPeak = this.mergeBMLSyncFix(bml.attackPeak, bml.start, globalStart);	if ( !isNaN(bml.ready) )		bml.ready = this.mergeBMLSyncFix(bml.ready, bml.start, globalStart);	if ( !isNaN(bml.strokeStart) )		bml.strokeStart = this.mergeBMLSyncFix(bml.strokeStart, bml.start, globalStart);	if ( !isNaN(bml.stroke) )		bml.stroke = this.mergeBMLSyncFix(bml.stroke, bml.start, globalStart);	if ( !isNaN(bml.strokeEnd) )		bml.strokeEnd = this.mergeBMLSyncFix(bml.strokeEnd, bml.start, globalStart);	if ( !isNaN(bml.relax))		bml.relax = this.mergeBMLSyncFix(bml.relax, bml.start, globalStart);	bml.start = 0;	bml.composition = composition;	let overwrite = composition === "OVERWRITE";	let merge = composition === "MERGE";	if ( !overwrite ) {		stack.push( bml );		// bubble sort the stack by endGlobalTime. First the lowest 		for( let i = stack.length-2; i > 0; --i){			if ( stack[i].endGlobalTime > bml.endGlobalTime ){				stack[i+1] = stack[i];				stack[i] = bml;			}			else { break; }		}		return true;	}	// OLD CODE	// add to bml stack	// Empty	if (stack.length == 0) {		stack.push( bml );		return true;	}	else {		// Fits between		if (stack.length > 1) {			//append at the end			if (bml.startGlobalTime >= stack[stack.length - 1].endGlobalTime){				stack.push(bml);				merged = true;			}			// fit on the stack?			else{				for (let i = 0; i < stack.length-1; i++){					if(merged) break;					// Does it fit?					if (bml.startGlobalTime >= stack[i].endGlobalTime && bml.endGlobalTime <= stack[i + 1].startGlobalTime || i == 0 && bml.endGlobalTime < stack[i].startGlobalTime) {						let tmp = stack.splice(i, stack.length);						stack.push(bml);						stack = stack.concat(tmp);						merged = true;					}					// If it doesn't fit remove if overwrite					else if (overwrite) {						// Remove from bml stack						stack.splice(i, 1);						i--;					}					else if(merge){						stack.push(bml);						merged = true;					}				}			}		}		// End of stack (stack.length == 1)		if (!merged || overwrite) {			// End of stack			if (stack[stack.length - 1].endGlobalTime <= bml.startGlobalTime) {				if (!merged) {					stack.push(bml);					merged = true;				}			}			else if (overwrite)				stack.splice(stack.length - 1, 1);			else if (bml.endGlobalTime < stack[0].startGlobalTime) {// Start of stack				stack.push(bml);				stack.reverse();			}		}	}	// After removing conflicting bml, add	if (overwrite && !merged) {		stack.push(bml);		merged = true;	}	return merged;}// Fix ref to another block (negative global timestamp) and remove start offsetBehaviourManager.prototype.mergeBMLSyncFix = function (syncAttr, start, globalStart) {	return ( syncAttr > start ) ? ( syncAttr - start ) : 0;	// ORIGINAL FUNCTION BELOW	// Ref to another block	if (syncAttr < 0) syncAttr = (-syncAttr) - globalStart;	// Remove offset	syncAttr -= start;	// Check error	if (syncAttr < 0)		console.error("BML sync attribute is negative.", syncAttr, start, globalStart);	return syncAttr;}// Checks that all stacks are ordered according to the timeline (they should be as they are insterted in order)BehaviourManager.prototype.check = function () {	if (this.errorCheck(this.blinkStack)) console.error("Previous error is in blink stack");	if (this.errorCheck(this.gazeStack)) console.error("Previous error is in gaze stack");	if (this.errorCheck(this.faceStack)) console.error("Previous error is in face stack");	if (this.errorCheck(this.headStack)) console.error("Previous error is in head stack");	if (this.errorCheck(this.headDirStack)) console.error("Previous error is in headDir stack");	if (this.errorCheck(this.speechStack)) console.error("Previous error is in speech stack");	if (this.errorCheck(this.postureStack)) console.error("Previous error is in posture stack");	if (this.errorCheck(this.gestureStack)) console.error("Previous error is in gesture stack");	if (this.errorCheck(this.pointingStack)) console.error("Previous error is in pointing stack");	if (this.errorCheck(this.lgStack)) console.error("Previous error is in lg stack");	if (this.errorCheck(this.animationStack)) console.error("Previous error is in animation stack");}BehaviourManager.prototype.errorCheck = function (stack) {	// Check timings	for (let i = 0; i < stack.length - 1; i++) {		if (stack[i].endGlobalTime > stack[i + 1].startGlobalTime) {			console.error("Timing error in stack: ", stack);			return true;		}	}}
//@BehaviourPlanner//Agent's communicative intentions specified using BML standard//StatesBehaviourPlanner.WAITING = 0;BehaviourPlanner.PROCESSING = 1;BehaviourPlanner.SPEAKING = 2;BehaviourPlanner.LISTENING = 3;function BehaviourPlanner() {  this.reset();}BehaviourPlanner.prototype.reset = function () {  this.conversation = "--- New dialogue---\n\n";  this.state = BehaviourPlanner.WAITING;    //For automatic state update  this.stateTime = 0;  this.nextBlockIn =  1 + Math.random() * 2;    // Default facial state  this.defaultValence = 0.4;  this.currentArousal = 0;    // Idle timings (blink and saccades)  this.blinkIdle = 0.5 + Math.random()*6;	this.blinkDur = Math.random()*0.5 + 0.15;	this.blinkCountdown = 0;	this.saccIdle = 0.5 + Math.random()*6;	this.saccDur = Math.random() + 0.5;	this.saccCountdown = 0;}//UPDATEBehaviourPlanner.prototype.update = function(dt){  this.stateTime += dt;    // Automatic state update  if (this.nextBlockIn < this.stateTime){    this.stateTime = 0;    return this.createBlock();  }    // Check if speech has finished to change to WAITING  /*if (this.state == BehaviourPlanner.SPEAKING){    if (BehaviourPlanner.BehaviorManager){      if (BehaviourPlanner.BehaviorManager.lgStack.length == 0 && BehaviourPlanner.BehaviorManager.speechStack.length == 0)        this.transition({control: BehaviourPlanner.WAITING});    }  }*/    // Automatic blink and saccades  return this.updateBlinksAndSaccades(dt);}//TRANSITION to nextStateBehaviourPlanner.prototype.transition = function(block){    var nextState = block.control;    if (nextState == this.state)    return;    var currentState = "waiting";    switch(this.state){    case BehaviourPlanner.WAITING:      currentState = "waiting";      break;    case BehaviourPlanner.LISTENING:      currentState = "listening";      break;      case BehaviourPlanner.SPEAKING:      currentState = "speaking";      break;      case BehaviourPlanner.PROCESSING:      currentState = "processing";      break;  }    // Reset state time  this.stateTime = 0;    // TRANSITIONS  switch(nextState){  	      // Waiting can only come after speaking    case BehaviourPlanner.WAITING:    	// Look at user for a while, then start gazing around    	this.nextBlockIn = 2 + Math.random() * 4;  		break;  	      // Can start speaking at any moment    case BehaviourPlanner.LISTENING:    	// Force to overwrite existing bml    	block.composition = "MERGE";    	/*if(this.state ==BehaviourPlanner.SPEAKING){      	// Abort speech      	this.abortSpeech();    	}*/    	// Look at user and default face    	this.attentionToUser(block, true);    	// Back-channelling    	this.nextBlockIn = 0 +  Math.random()*2;			break;    		// Processing always after listening    case BehaviourPlanner.PROCESSING:    	this.nextBlockIn = 0;  		break; 	 		      // Speaking always after processing    case BehaviourPlanner.SPEAKING:    	this.attentionToUser(block, true);    	// Should I create random gestures during speech?    	this.nextBlockIn = Math.random()*1;//2 + Math.random()*4;  	break;  }    this.state = nextState;  }//!!!!!!!!!!!!!!!!!!/*BehaviourPlanner.prototype.abortSpeech = function(){  // Cancel audio and lipsync in Facial  if (BehaviourPlanner.Facial){    var facial = BehaviourPlanner.Facial;    if (!facial._audio.paused){    	facial._audio.pause(); // Then paused is true and no facial actions      // Go to neutral face? Here or somewhere else?    }  }  // End all blocks in BMLManager  if (BehaviourPlanner.BMLManager){    var manager = BehaviourPlanner.BMLManager;    for (var i =0 ; i < manager.stack.length; i++){      manager.stack[i].endGlobalTime = 0;    }  }}*///---------------------------AUTOMATIC------------------------------//CREATEBLOCKs during a state (automatic)BehaviourPlanner.prototype.createBlock = function(){    var state = this.state;  var block = {    id: state,     composition: "MERGE"  };    switch(state)  {  // LISTENING    case BehaviourPlanner.LISTENING:      this.nextBlockIn = 1.5 + Math.random()*3;      // head -> link with this.currentArousal      if (Math.random() < 0.4)      {        block.head = {          start: 0,          end: 1.5 + Math.random()*2,          lexeme: "NOD",          amount: 0.05 + Math.random()*0.05,          type:"head"        }      }      // Esporadic raising eyebrows      if (Math.random() < 0.5)      {        var start = Math.random();        var end = start + 1 + Math.random();        block.face = [{          start: start,          attackPeak: start + (end-start)*0.2,          relax: start + (end-start)*0.5,          end: end,          lexeme: {            lexeme: "BROW_RAISER",             amount: 0.1 + Math.random()*0.2          },          type:"face"        },          {          start: start,          attackPeak: start + (end-start)*0.2,          relax: start + (end-start)*0.5,          end: end,          lexeme: {            lexeme: "UPPER_LID_RAISER",             amount: 0.1 + Math.random()*0.2        	},          type:"face"        }]              }      if(Math.random() < 0.2){        var start = Math.random();        var end = start + 1 + Math.random();        var f = {          start: start,          attackPeak: start + (end-start)*0.2,          relax: start + (end-start)*0.5,          end: end,          lexeme: {            lexeme: "CHEEK_RAISER",             amount: 0.1 + Math.random()*0.2        	},          type:"face"        }        if(block.face)          block.face.push(f)        else          block.face = f;      }      // Gaze should already be towards user      break;    // SPEAKING    case BehaviourPlanner.SPEAKING:            this.nextBlockIn = 2 + Math.random()*4;      // Head      if (Math.random() < 0.2){        // Deviate head slightly        if (Math.random() < 0.85)        {          var start = Math.random();          var offsetDirections = ["CAMERA","DOWNRIGHT", "DOWNLEFT", "LEFT", "RIGHT"]; // Upper and sides          var randOffset = offsetDirections[Math.floor(Math.random() * offsetDirections.length)];          // block.headDirectionShift = {          //   start: start,          //   end: start + Math.random(),          //   target: "CAMERA",          //   offsetDirection: randOffset,          //   offsetAngle: 1 + Math.random()*3,          //   type:"headDirectionShift"          // }        }      }      // Esporadic raising eyebrows      if (Math.random() < 0.7)      {        var start = Math.random();        var end = start + 1.2 + Math.random()*0.5;        block.face = {          start: start,          attackPeak: start + (end-start)*0.2,          relax: start + (end-start)*0.5,          end: end,          lexeme: {            lexeme: "BROW_RAISER",             amount: 0.1 + Math.random()*0.2          },           type:"face"        }      }      // Redirect gaze to user      if (Math.random() < 0.7)      {        // var start = Math.random();        // var end = start + 0.5 + Math.random()*1;        // block.gazeShift = {        //   start: start,        //   end: end,        //   influence: "EYES",        //   target: "CAMERA",        //   type:"gazeShift"        // }        block.composition = "MERGE";      }    	break;      // PROCESSING    case BehaviourPlanner.PROCESSING:      this.nextBlockIn = 2 + Math.random() * 2;      // gaze      var offsetDirections = ["UPRIGHT", "UPLEFT", "LEFT", "RIGHT"]; // Upper and sides      var randOffset = offsetDirections[Math.floor(Math.random() * offsetDirections.length)];      if(Math.random() < 0.8)      {        // block.gazeShift = {        //   start: 0,        //   end: 1 + Math.random(),        //   influence: "EYES",        //   target: "CAMERA",        //   offsetDirection: randOffset,        //   offsetAngle: 10 + 5*Math.random(),        //   type:"gazeShift"        // }      }      // head nods      if (Math.random() < 0.3)      {        // block.head = {        //   start: 0,        //   end: 1.5 + Math.random()*2,        //   lexeme: Math.random() < 0.2 ? "TILT" : "NOD",        //   amount: 0.05 + Math.random()*0.1,        //   type:"head"        // }      }      // frown      if (Math.random() < 0.6)      {        block.face = {          start: 0,          end: 1 + Math.random(),          lexeme: [            {              lexeme: "BROW_LOWERER",               amount: 0.2 + Math.random()*0.5            }          ],          type:"face"        }      }      // press lips      if (Math.random() < 0.3)      {        var lexeme = {          lexeme: "LIP_PRESSOR",          amount: 0.1 + 0.3 * Math.random()        };        if(block.face)          block.face.lexeme.push(lexeme)        else          block.face = {            start: 0,            end: 1 + Math.random(),            lexeme: lexeme        }          block.face.type="face"      }      break;    // WAITING    case BehaviourPlanner.WAITING:            this.nextBlockIn = 2 + Math.random() * 3;      // gaze      var offsetDirections = ["CAMERA","DOWN", "DOWNRIGHT", "DOWNLEFT", "LEFT", "RIGHT"]; // Upper and sides      var randOffset = offsetDirections[Math.floor(Math.random() * offsetDirections.length)];      // block.gazeShift = {      //   start: 0,      //   end: 1 + Math.random(),      //   target: "CAMERA",      //   influence: Math.random()>0.5 ? "HEAD":"EYES",      //   offsetDirection: offsetDirections[randOffset],      //   offsetAngle: 5 + 5*Math.random(),      //   type:"gazeShift"      // }      // Set to neutral face (VALENCE-AROUSAL)      //block.faceShift = {start: 0, end: 2, valaro: [0,0], type:"faceShift"};      block.composition = "MERGE"     	break;  }  return block;}// -------------------- NEW BLOCK --------------------// New block arrives. It could be speech or control.BehaviourPlanner.prototype.newBlock = function(block){    // State  if ( block.control ){    this.transition(block);  }	// If non-verbal -> inside mode-selection.nonverbal	if (block.nonVerbal){		// Add gesture (check arousal of message)    if (block.nonVerbal.constructor === Array){ // It is always an array in server      for (var i = 0; i < block.nonVerbal.length; i++){ // TODO -> relate nonVerbal with lg        var act = block.nonVerbal[i].dialogueAct;        block.gesture = {lexeme: act, start: 0, end: 2, type:"gesture"};      }    }    	}}// Automatic blink and saccades// http://hal.univ-grenoble-alpes.fr/hal-01025241/documentBehaviourPlanner.prototype.updateBlinksAndSaccades = function(dt){  // Minimum time between saccades 150ms  // Commonly occurring saccades 5-10 deg durations 30-40ms  // Saccade latency to visual target is 200ms (min 100 ms)  // Frequency?    // 10-30 blinks per minute during conversation (every two-six seconds)  // 1.4 - 14 blinks per min during reading    var block = null;     // Saccade  this.saccCountdown += dt;  if (this.saccCountdown > this.saccIdle){    // Random direction    var opts = ["RIGHT", "LEFT", "DOWN","DOWNRIGHT", "DOWNLEFT", "UP", "UPLEFT", "UPRIGHT"]; // If you are looking at the eyes usually don't look at the hair    var randDir = opts[Math.floor(Math.random()*opts.length)];        // Fixed point to saccade around?    var target = "CAMERA"//"EYESTARGET";    if (this.state == BehaviourPlanner.LISTENING)       target = "CAMERA";            if (!block)       block = {};        // block.gaze = {    //   start: 0,    //   end: Math.random()*0.1+0.1,    //   target: target,     //   influence: "EYES",    //   offsetDirection: "CAMERA",    //   offsetAngle: Math.random()*3 + 2,    //   type:"gaze"    // }        this.saccCountdown = this.saccDur;    if (this.state ==BehaviourPlanner.LISTENING || this.state == BehaviourPlanner.SPEAKING)      this.saccIdle = this.saccDur + 2 + Math.random()*6;    else  		this.saccIdle = this.saccDur + 0.5 + Math.random()*6;  	    this.saccDur = Math.random()*0.5 + 0.5;  }    return block;}BehaviourPlanner.prototype.attentionToUser = function(block, overwrite){  // If gazeShift already exists, modify	var end = 0.5 + Math.random();	var startHead = 0;  var startGaze = startHead + Math.random()*0.5; // Late start  	// gazeShift	// var gazeShift = {  //   id: "gazeEnd",	// 	start: startGaze,	// 	end: end,	// 	influence: "EYES",	// 	target: "CAMERA",  //   type:"gazeShift"	// }  	// headDirectionShift	var offsetDirections = ["CAMERA","DOWN", "DOWNLEFT", "DOWNRIGHT"]; // Submissive? Listening?  var randOffset = offsetDirections[Math.floor(Math.random() * offsetDirections.length)];	var startDir = -Math.random()*0.3;	// var headDir = {	// 	start: startHead,	// 	end: end,	// 	target: "CAMERA",  //   offsetDirection: "CAMERA",  //   offsetAngle: 2 + 5*Math.random(),  //   type:"headDirectionShift"	// }    var faceVA = {    start: startHead,    end: end,    valaro: [this.defaultValence, 0],    type:"faceVA",    shift : true  }    // Force and remove existing bml instructions  if (overwrite)  {    //block.blink = blink;    //block.faceVA = faceVA;    // block.gazeShift = gazeShift;    // block.headDirectionShift = headDir;  }   else  {    //this.addToBlock(blink, block, "blink");    //this.addToBlock(faceVA, block, "faceVA");    // this.addToBlock(gazeShift, block, "gazeShift");    // this.addToBlock(headDir, block, "headDirectionShift");  }}BehaviourPlanner.prototype.addToBlock = function(bml, block, key){  if (block[key])  {    // Add to array (TODO: overwrite, merge etc...)    if (block[key].constructor === Array)    {      if (bml.constructor === Array)        for (var i = 0; i<bml.length; i++)          block[key].push(bml[i]);      else        block[key].push(bml);    }    // Transform object to array    else {      var tmpObj = block[key];      block[key] = [];      block[key].push(tmpObj);      if (bml.constructor === Array)        for (var i = 0; i<bml.length; i++)          block[key].push(bml[i]);       else        block[key].push(bml);    }  }   // Doesn't exist yet  else    block[key] = bml;  }// ---------------------------- NONVERBAL GENERATOR (for speech) ----------------------------// Process language generation message// Adds new bml instructions according to the dialogue act and speech//BehaviourPlanner.prototype.processSpeechBlock = function (bmlLG, block, isLast){}// Use longest word as prosody mark//BehaviourPlanner.prototype.createBrowsUp = function (bmlLG){}// Generate faceShifts at the end of speech//BehaviourPlanner.prototype.createEndFace = function (bmlLG){}// Create a head nod at the beggining//BehaviourPlanner.prototype.createHeadNodStart = function (bmlLG){}// Create gaze (one at start to look away and back to user)//BehaviourPlanner.prototype.createGazeStart = function (bmlLG){}// Look at the camera at the end//BehaviourPlanner.prototype.createGazeEnd = function (bmlLG){}// Change offsets of new bml instructions//BehaviourPlanner.prototype.fixSyncStart = function (bml, offsetStart){}// Add a pause between speeches//BehaviourPlanner.prototype.addUtterancePause = function (bmlLG){}
//@BehaviorRealizerlet DEG2RAD = Math.PI / 180;let RAD2DEG = 180 / Math.PI;// --------------------- BLINK ---------------------// BML// <blink start attackPeak relax end amount>function Blink() {        this.start = 0;    this.end = 0;    this.elapsedTime = 0;    this.initWs = [0, 0]; // initial pose of eyelids    this.endWs = [0, 0]; // target pose of eyelids ( constantly changes during update )    this.weights = [0, 0]; // current status    this.needsInit = true;    this.blinking = false;    this.between = false;    }Blink.prototype.getEnd = function () {        return 0.5; //1000; //Math.random()*1000;}Blink.prototype.initBlinking = function (cw0, cw1) {        if( this.blinking ){ // forced a blink while already executing one        this.initWs[0] = this.weights[0]; this.initWs[1] = this.weights[1];    }else{        this.initWs[0] = cw0; this.initWs[1] = cw1;        this.weights[0] = cw0; this.weights[1] = cw1;    }    this.endWs[0] = cw0; this.endWs[1] = cw1;        this.elapsedTime = 0;    this.start = 0;    let lowestWeight = Math.min(cw0, cw1);    lowestWeight = Math.min(1, Math.max(0, lowestWeight));    this.end = this.getEnd() * (1 - lowestWeight);    this.end = Math.max(this.end, this.start); // just in case    this.needsInit = false;    this.blinking = true;    this.between = false;}Blink.prototype.blink = function () {        this.start = -1;    this.elapsedTime = -1;    this.needsInit = true;    this.between = false;    // this.blinking = true;    // this.between = false;}Blink.prototype.update = function ( dt, currentWeight0, currentWeight1 ) {    if ( this.needsInit ) {        this.initBlinking( currentWeight0, currentWeight1 );    }    if ( this.blinking && dt > 0 ) {        this.elapsedTime += dt;        this.endWs[0] = currentWeight0;        this.endWs[1] = currentWeight1;        this.computeWeight( this.elapsedTime );        if (this.elapsedTime > this.end ) { // schedule next blink            this.blinking = false;            this.between = true;            setTimeout( this.blink.bind( this ), Math.random() * 3000 + 1500 );            return;        }    }}//Paper --> Eye Movement Synthesis with 1/ f Pink Noise -- Andrew Duchowski∗, Sophie Jörg, Aubrey Lawson, Takumi Bolte, Lech Swirski  ́// W(t) = -> a - (t/mu)^2 if t<=mu//        -> b - e^(-w*log(t-mu+1)) otherwise// where t = [0,100] normalized percent blink duration // mu = 37 when the lid should reach full closure// a = 0.98 percent lid closure at the start of the blink// b = 1.18 // w = mu/100 parameters used to shape the asymptotic lid opening dunctionBlink.prototype.computeWeight = function (dt) {        let t = (dt - this.start) / (this.end - this.start) * 100;    t = Math.min(100, Math.max(0, t));    let mu = 37;    let a = 1;    let b = 1.18;    let c = mu / 100;    let w = 0;    let srcWs = null;    if (t <= mu) {        w = a - Math.pow(t / mu, 2);        srcWs = this.initWs;    } else {        w = b - Math.pow(Math.E, (-c * Math.log2(t - mu + 1)));        srcWs = this.endWs;    }    w = Math.min(1, Math.max(0, w));    this.weights[0] = 1 - w * (1 - srcWs[0]);    this.weights[1] = 1 - w * (1 - srcWs[1]);}// --------------------- FACIAL EXPRESSIONS ---------------------// BML// <face or faceShift start attackPeak relax* end* valaro// <faceLexeme start attackPeak relax* end* lexeme amount// <faceFacs not implemented>// lexeme  [OBLIQUE_BROWS, RAISE_BROWS,//      RAISE_LEFT_BROW, RAISE_RIGHT_BROW,LOWER_BROWS, LOWER_LEFT_BROW,//      LOWER_RIGHT_BROW, LOWER_MOUTH_CORNERS,//      LOWER_LEFT_MOUTH_CORNER,//      LOWER_RIGHT_MOUTH_CORNER,//      RAISE_MOUTH_CORNERS,//      RAISE_RIGHT_MOUTH_CORNER,//      RAISE_LEFT_MOUTH_CORNER, OPEN_MOUTH,//      OPEN_LIPS, WIDEN_EYES, CLOSE_EYES]//// Static // first row = blendshape indices || second row = blendshape proportional amount (some blendshapes are slightly used, others are fully used)FacialExpr.NMF = {}; // lookup table for lexeme-blendshape relation// SignON actions unitsFacialExpr.NMF.NMF_FROWN =                  [[2, 3, 4, 5], [1, 1, 1, 1]];FacialExpr.NMF.NMF_ARCH =                   [[6, 7, 8, 9], [1, 1, 1, 1]];FacialExpr.NMF.NMF_OPEN_WIDE_EYE =          [[12, 13], [1, 1]];FacialExpr.NMF.NMF_SQUINT =                 [[43, 44], [1, 1]];FacialExpr.NMF.NMF_BLINK =                  [[0, 1], [1, 1]];FacialExpr.NMF.NMF_CLOSED =                 [[0, 1], [1, 1]];FacialExpr.NMF.NMF_SUCK_IN_RIGHT =          [[11], [-1]];     // missing new blendshapesFacialExpr.NMF.NMF_SUCK_IN_LEFT =           [[10], [-1]];     // missing new blendshapesFacialExpr.NMF.NMF_SUCK_IN_BOTH =           [[10, 11], [-1, -1]]; // missing new blendshapesFacialExpr.NMF.NMF_BLOW_RIGHT =             [[11], [1]];FacialExpr.NMF.NMF_BLOW_LEFT =              [[10], [1]];FacialExpr.NMF.NMF_BLOW_BOTH =              [[10, 11], [1, 1]];FacialExpr.NMF.NMF_OPEN_WIDE_MOUTH =        [[35], [1]];FacialExpr.NMF.NMF_CLOSE_TIGHT =            [[28, 33, 34, 47], [1, 1, 1, -1]];FacialExpr.NMF.NMF_SMILE_TEETH =            [[41, 42, 35], [0.5, 0.5, 0.2]];FacialExpr.NMF.NMF_SMILE_TEETH_WIDE =       [[41, 42, 35], [1, 1, 0.2]];FacialExpr.NMF.NMF_SMILE_CLOSED =           [[41, 42], [1, 1]];FacialExpr.NMF.NMF_ROUND_OPEN =             [[33, 34, 35], [0.7, 0.7, 0.7]];// missing new blendshapeFacialExpr.NMF.NMF_ROUND_CLOSED =           [[33, 34], [1, 1]];FacialExpr.NMF.NMF_OUT_POINTED =            [[], []];       // missing new blendshapesFacialExpr.NMF.NMF_OUT_ROUND =              [[], []];       // missing new blendshapesFacialExpr.NMF.NMF_CRINKLE =                [[39, 40], [1, 1]];FacialExpr.NMF.NMF_FLARE =                  [[], []];       // missing new blendshapeFacialExpr.NMF.NMF_MOUTH_DOWN =             [[32], [1]];// others (legacy mainly)FacialExpr.NMF.LIP_CORNER_DEPRESSOR =       [[14,15], [1,1]]; // AU15 sadFacialExpr.NMF.LIP_CORNER_DEPRESSOR_LEFT =  [[14], [1]]; // LAU15 sadFacialExpr.NMF.LIP_CORNER_DEPRESSOR_RIGHT = [[15], [1]]; // RAU15 sadFacialExpr.NMF.LIP_CORNER_PULLER =          [[41,42], [1,1]]; // AU12 happyFacialExpr.NMF.LIP_CORNER_PULLER_LEFT =     [[41], [1]]; // LAU12 happyFacialExpr.NMF.LIP_CORNER_PULLER_RIGHT =    [[42], [1]]; // RAU12 happyFacialExpr.NMF.LIP_STRECHER =               [[14,15,32], [1,1,1]];// AU20FacialExpr.NMF.LIP_FUNNELER =               [[37,38], [1,1]];     // AU22FacialExpr.NMF.LIP_TIGHTENER =              [[30,31], [1,1]];     // AU23FacialExpr.NMF.LIP_PUCKERER =               [[33,34], [1,1]]; // AU18 mouth narrowFacialExpr.NMF.LIP_PUCKERER_LEFT =          [[33], [1]]; // AU18L mouth narrow leftFacialExpr.NMF.LIP_PUCKERER_RIGHT =         [[34], [1]]; // AU18R mouth narrow rightFacialExpr.NMF.LIP_PRESSOR =                [[25,28,46], [1,1,1]];// AU24FacialExpr.NMF.LIPS_PART =                  [[29, 33, 34, 35, 47], [0.2, -0.05, -0.05, 0.1, 0.2]]; //AU25FacialExpr.NMF.LIP_SUCK =                   [[28, 46], [1,1]];// AU28FacialExpr.NMF.LIP_SUCK_UPPER =             [[46], [1]];// AU28U upper lip inFacialExpr.NMF.LIP_SUCK_LOWER =             [[28], [1]];// AU28D lower lip inFacialExpr.NMF.LOWER_LIP_DEPRESSOR =        [[26,27], [1,1]]; // AU16FacialExpr.NMF.UPPER_LIP_RAISER =           [[48,49], [1,1]]; // AU10FacialExpr.NMF.UPPER_LIP_RAISER_LEFT =      [[48], [1]]; // AU10LFacialExpr.NMF.UPPER_LIP_RAISER_RIGHT =     [[49], [1]]; // AU10RFacialExpr.NMF.CHIN_RAISER =                [[36], [1]]; // AU17 mouth upFacialExpr.NMF.DIMPLER =                    [[33,34,26,27,48,49,28,46], [-0.753,-0.753,-0.35,-0.35,-0.15,-0.15,1,0.1]]; // AU14 -- MouthNarrow + LowerLipDown + UpperLipUp + LowerLipIn + UpperLipIn FacialExpr.NMF.DIMPLER_LEFT =               [[33,26,48,28,46], [-0.753,-0.25,-0.15,1.0,0.1]]; // LAU14FacialExpr.NMF.DIMPLER_RIGHT =              [[34,26,27,48,49,28,46], [-0.753,-0.25,-0.25,-0.15,-0.15,1.0,0.1]]; // RAU14 -- for some reason right side looks differentFacialExpr.NMF.NOSE_WRINKLER =              [[39,40], [1,1]]; // AU9FacialExpr.NMF.MOUTH_STRETCH =              [[35], [1]]; // AU27FacialExpr.NMF.MOUTH_OPEN =                 [[35], [1]]; // jawFacialExpr.NMF.JAW_DROP =                   [[22], [1]]; // AU26FacialExpr.NMF.JAW_SIDEWAYS_LEFT =          [[18], [1]]; // AU30LFacialExpr.NMF.JAW_SIDEWAYS_RIGHT =         [[19], [1]]; // AU30RFacialExpr.NMF.JAW_THRUST =                 [[17], [1]]; // AU29FacialExpr.NMF.TONGUE_SHOW =                [[45], [1]]; // AU19FacialExpr.NMF.CHEEK_BLOW =                 [[10, 11, 33, 34], [1, 1, -0.3, -0.3]]; //AU33FacialExpr.NMF.CHEEK_SUCK =                 [[10, 11, 33, 34, 35, 37, 38], [-0.8, -0.8, 0.6, 0.6, -0.1, 0.4, 0.4]]; //AU35FacialExpr.NMF.BROW_LOWERER =               [[2,3,4,5], [1,1,1,1]]; // AU4 FacialExpr.NMF.BROW_LOWERER_LEFT =          [[2,4], [1,1]]; // FacialExpr.NMF.BROW_LOWERER_RIGHT =         [[3,4], [1,1]]; // brows downFacialExpr.NMF.BROW_RAISER =                [[8,9], [1,1]]; //  brow upFacialExpr.NMF.BROW_RAISER_LEFT =           [[8], [1]]; // left brow upFacialExpr.NMF.BROW_RAISER_RIGHT =          [[9], [1]]; // right brow upFacialExpr.NMF.INNER_BROW_RAISER =          [[6,7], [1,1]]; // AU1 rows rotate outwardsFacialExpr.NMF.OUTER_BROW_RAISER =          [[8,9], [1,1]]; // AU2 brows up (right)FacialExpr.NMF.UPPER_LID_RAISER =           [[12,13], [1,1]]; // AU5 negative eyelids closed /wide eyesFacialExpr.NMF.UPPER_LID_RAISER_LEFT =      [[12], [1]]; // AU5 negative eyelids closed /wide eyesFacialExpr.NMF.UPPER_LID_RAISER_RIGHT =     [[13], [1]]; // AU5 negative eyelids closed /wide eyesFacialExpr.NMF.CHEEK_RAISER =               [[43,44], [1,1]]; // AU6 squintFacialExpr.NMF.LID_TIGHTENER =              [[43,44], [1,1]]; // AU7 or AU44 squintFacialExpr.NMF.EYES_CLOSED =                [[0,1], [1,1]]; // AU43 eyelids closedFacialExpr.NMF.BLINK =                      [[0,1], [1,1]]; // AU45 eyelids closedFacialExpr.NMF.WINK_LEFT =                  [[0], [1]]; // AU46   FacialExpr.NMF.WINK_RIGHT =                 [[1], [1]]; // AU46   // Constructorfunction FacialExpr(faceData, shift) {        this.transition = false;    let thing = faceData.lexeme;    thing = (!thing) ? faceData.au : thing;    // Init face lexemes     if (thing) {        // faceLexeme        if (typeof (thing) == "string") //(lexeme/au = "STRING")            this.initFaceLexeme(faceData, shift, [faceData])        // One lexeme object inside face/faceShift (faceData.lexeme = {lexeme:"RAISE_BROWS"; amount: 0.1})        else if (typeof (thing) == "object" && thing.length === undefined)            this.initFaceLexeme(faceData, shift, [thing]);        // Several lexemes/au inside face/faceShift (faceData.lexeme = [{}, {}]...)        else if (typeof (thing) == "object" && thing.length !== undefined)            this.initFaceLexeme(faceData, shift, thing);        return;    }}// There can be several facelexemes working at the same time then? lexemes is an array of lexeme objectsFacialExpr.prototype.initFaceLexeme = function (faceData, shift, lexemes) {    // Sync    this.start = faceData.start || 0.0;    this.end = faceData.end;    if (!shift) {        this.attackPeak = faceData.attackPeak || (this.end - this.start) * 0.25 + this.start;        this.relax = faceData.relax || (this.end - this.attackPeak) / 2 + this.attackPeak;    } else {        this.end = faceData.end || faceData.attackPeak || 0.0;        this.attackPeak = faceData.attackPeak || this.end;        this.relax = 0;    }    // Initial blend shapes and targets    // Choose the ones to interpolate    this.indicesLex = [];    this.targetLexBSW = [];    this.currentLexBSW = [];    let j = 0; // index of accepted lexemes    for (let i = 0; i < lexemes.length; i++) {        if (typeof (lexemes[i].lexeme) !== "string") { lexemes[i].lexeme = "NO_LEXEME"; }        let lexemeStr = lexemes[i].lexeme || lexemes[i].au;        // does lexeme exist?        if ( !FacialExpr.NMF[lexemeStr] ) {            this.transition = false;            this.time = this.end;            console.warn("Facial lexeme not found:", lexemeStr, ". Please refer to the standard.");            continue;        }        // FacialExpr.NMF[lexemeStr] returns array [ BlendshapeIndices, weights ]        let indices = FacialExpr.NMF[lexemeStr][0]; // get only the blendshape indices        let weights = FacialExpr.NMF[lexemeStr][1]; // get only the blendshape weights        // Indices        this.indicesLex[j] = indices;        this.targetLexBSW[j] = [];        this.currentLexBSW[j] = [];        // ensure lexeme has an intensity        let lexemeAmount = lexemes[i].amount;        lexemeAmount = (isNaN(lexemeAmount)) ? faceData.amount : lexemeAmount;        lexemeAmount = (isNaN(lexemeAmount)) ? 1 : lexemeAmount;        // set initial and target blendshape values for this lexeme        for (let e = 0; e < indices.length; ++e) {            this.targetLexBSW[j][e] = lexemeAmount * weights[e];            this.currentLexBSW[j][e] = 0;        }        j++;    }    // Start    this.transition = true;    this.time = 0;}FacialExpr.prototype.updateLexemesBSW = function (dt) {    // Immediate change    if (this.attackPeak == 0 && this.end == 0 && this.time == 0) {        for (var i = 0; i < this.indicesLex.length; i++)            for (var j = 0; j < this.indicesLex[i].length; j++)                this.currentLexBSW[i][j] = this.targetLexBSW[i][j];        // Increase time and exit        this.time += dt;        return;    }    // Time increase    this.time += dt;    // Wait for to reach start time    if (this.time < this.start) { return; }    let inter = 0;    if (this.time < this.start) {        // did not even start        inter = 0;    } else if (this.time < this.attackPeak) {        // Trans 1 - intro        inter = (this.time - this.start) / (this.attackPeak - this.start);        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;    } else if (this.time < this.relax) {        // Stay still from attackPeak to relax        inter = 1;    } else if (this.time < this.end) {        // Trans 2 - outro        inter = (this.time - this.relax) / (this.end - this.relax);        inter = 1 - inter; // outro goes from target to 0        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;    } else {        // end        inter = 0;        this.transition = false;    }    // Interpolation    for (var i = 0; i < this.indicesLex.length; i++) {        for (var j = 0; j < this.indicesLex[i].length; j++) {            this.currentLexBSW[i][j] = inter * this.targetLexBSW[i][j];        }    }}// ---------------------------------------- FacialEmotion ----------------------------------// Variables for Valence Arousal// Psyche Interpolation Table/*FacialExpr.prototype._pit = [0.000, 0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,                            0.000,  1.000,  0.138,  1.00,  0.000,  0.675,  0.000,  0.056,  0.200,  0.116,  0.100,                            0.500,  0.866,  0.000,  0.700,  0.000,  0.000,  0.000,  0.530,  0.000,  0.763,  0.000,                            0.866,  0.500,  0.000,  1.000,  0.000,  0.000,  0.600,  0.346,  0.732,  0.779,  0.000,                            1.000,  0.000,  0.065,  0.000,  0.344,  0.344,  0.700,  0.000,  0.000,  1.000,  -0.300,                            0.866,  -0.500, 0.391,  0.570,  0.591,  0.462,  1.000,  0.000,  0.981,  0.077,  0.000,                            0.500,  -0.866, 0.920,  0.527,  0.000,  0.757,  0.250,  0.989,  0.000,  0.366,  -0.600,                            0.000,  -1.000, 0.527,  0.000,  0.441,  0.531,  0.000,  0.000,  1.000,  0.000,  0.600,                            -0.707, -0.707, 1.000,  0.000,  0.000,  0.000,  0.500,  1.000,  0.000,  0.000,  0.600,                            -1.000, 0.000,  0.995,  0.000,  0.225,  0.000,  0.000,  0.996,  0.000,  0.996,  0.200,                            -0.707, 0.707,  0.138,  0.075,  0.000,  0.675,  0.300,  0.380,  0.050,  0.216,  0.300];*//* "valence", "arousal" ,"BLINK","CHEEK_RAISER", "LIP_CORNER_PULLER", "BROW_LOWERER", "DIMPLER", "OUTER_BROW_RAISER", "UPPER_LID_RAISER", "JAW_DROP","LID_TIGHTENER", "LIP_STRECHER","NOSE_WRINKLER", "LIP_CORNER_DEPRESSOR", "CHIN_RAISER", "LIP_CORNER_PULLER_RIGHT", "DIMPLER_RIGHT"*//*FacialExpr.prototype._pit = [  [0.95, 0.23 ,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0 ],//HAPPINESS  [-0.81, -0.57, 0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0 ], //SADNESS  [0.22, 0.98, 0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0 ], //SURPRISED  [-0.25, 0.98 ,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0 ], //FEAR  [-0.76, 0.64,0 , 0,0,0,1,0,1,0,1,0,1,0,0,0,0,0 ], //ANGER  [-0.96, 0.23,0, 0,0,0,0,0,0,0,0,0,0,1,1,1,0,0 ], //DISGUST  [-0.98, -0.21,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,1,1 ], //CONTEMPT  [0, 0 ,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ] //NEUTRAL  ]*/FacialEmotion.prototype.VALexemes = ["BLINK", "CHEEK_RAISER", "LIP_CORNER_PULLER", "BROW_LOWERER", "DIMPLER", "OUTER_BROW_RAISER", "UPPER_LID_RAISER", "JAW_DROP", "LID_TIGHTENER", "LIP_STRECHER", "NOSE_WRINKLER", "LIP_CORNER_DEPRESSOR", "CHIN_RAISER", "LIP_CORNER_PULLER_RIGHT", "DIMPLER_RIGHT"]FacialEmotion.prototype._pit = [    [//ANGRY         -0.76, 0.64, 0, 0, 0.37735849056603776, 0.37735849056603776, 0.660377358490566, 0.660377358490566, 0, 0, 0.006777392958909609, 0.006174350308024318, 0, 0, 0.008490566037735849, 0.008490566037735849, 0.3113207547169812, 0.3113207547169812, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.009433962264150943, 0.007983478260680202, 0.018497328267128684, 0, 0, 0.2655452832234524, 0.27559599407154056, 0.038135610804944806, 0.038135610804944806, 0.2358490566037736, 0.2358490566037736, 0, 0, 0, 0, 0    ],    [//HAPPY        0.95, 0.23, 0, 0, -0.18916378536627232, -0.179660980579041, 0, 0, 0, 0, 0, 0, 0, 0, 0.24764010809164083, 0.24764010809164083, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.20502509409574698, 0, 0, 0, 0, 0, 0.7803277830403155, 0.8111380948254938, 0, 0, 0, 0, 0, 0, 0    ],    [//SAD        -0.81, -0.57, 0, 0, 0, 0, 0, 0, 0.769674029541342, 0.8122890435372361, 0, 0, 0, 0, 0, 0, 0.5033301920670048, 0.46071517807111073, 0, 0.5565989595618721, 0, 0, 0, 0, 0, 0, 0, 0.3861389035782963, 0.02391128461319747, 0, 0, 0.5992139735577662, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0    ],    [//SURPRISED        0.22, 0.98, 0, 0, 0, 0, 0, 0, 0.2582938615906143, 0.21567884759472045, 0.3754851500793228, 0.3541776430813759, 0, 0, 0.5779064665598193, 0.5779064665598193, 0, 0, 0, 0, 0, 0, 0, 0, 0.3435238895824022, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2582938615906143, 0.26894761508958775, 0.13044881960293253, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0    ],    [//SACRED        -0.25, 0.98, 0, 0, 0.21567884759472045, 0.1943713405967733, 0.5, 0.5, 0.5246376990649517, 0.5, 0, 0, 0, 0, 0.15, 0.15, 0, 0, 0, 0, 0, 0, 0, 0, 0.3435238895824022, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2582938615906143, 0.26894761508958775, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0    ],    [//DISGUSTED        -0.96, 0.23, 0, 0, 0, 0, 0.42875391757419035, 0.49267643856803134, 0, 0, 0, 0, 0, 0, 0, 0, 0.23698635459266737, 0.15175632660087945, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.21567884759472045, 0, 0, 0.3104116803737398, 0.3541776430813759, 0, 0, 0.7, 0.7, 0, 0, 0, 0.4713689315700842, 0.3435238895824022    ],    [//CONTEMPT        -0.98, -0.21, 0.1, 0.1, 0, 0, 0, 0, 0, 0, 0.24764010809164083, 0.26894761508958775, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.4981226368365037, 0, 0, 0, 0, 0, 0, 0, 0.10914131260498539, 0, 0, 0, 0, 0, 0, 0, 0    ],    [//NEUTRAL        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0    ]]function FacialEmotion(sceneBSW) {        // The aim of this class is to contain the current emotion of the avatar. It is intended to be reused    this.gridSize = 100; // 100 x 100    this.precomputeVAWeights(this.gridSize); // this could be done as a static...    this.transition = false;    this.time = 0;    this.sceneBSW = sceneBSW;    // generate arrays for current, init and target. Current and init will be constantly swapped on initFaceVAlaro    this.initialVABSW = [];    this.targetVABSW = [];    this.currentVABSW = [];    if (sceneBSW) {        this.currentVABSW = this.sceneBSW["Body"].slice();    }    else {        this.currentVABSW = this._pit[0].slice(2); // first two elements of emotions are valence and arousal    }    this.currentVABSW.fill(0);    this.initialVABSW = this.currentVABSW.slice();    this.targetVABSW = this.currentVABSW.slice();    this.defaultVABSW = this.currentVABSW.slice();}FacialEmotion.prototype.reset = function () {        this.currentVABSW.fill(0);    this.initialVABSW.fill(0);    this.targetVABSW.fill(0);    this.defaultVABSW.fill(0);    this.transition = false;    this.time = 0;}FacialEmotion.prototype.precomputeVAWeights = function (gridsize = 100) {        // generates a grid of gridSize size, where for each point it determines which emotion is closer and its distance    // each emotion's valaro as point    let valAroPoints = [];    for (let count = 0; count < this._pit.length; count++) {        let point = new THREE.Vector2(this._pit[count][0], this._pit[count][1]);         valAroPoints.push(point);    }    let num_points = valAroPoints.length;    let pos = new THREE.Vector2();    // create grid    let total_nums = 2 * gridsize * gridsize;    this._precomputed_weights = new Float32Array(total_nums);    let values = this._precomputed_weights;    this._precomputed_weights_gridsize = gridsize;    // for each point in grid    for (var y = 0; y < gridsize; ++y)        for (var x = 0; x < gridsize; ++x) {            let nearest = -1;            let min_dist = 100000;            //normalize            pos.x = x / gridsize;            pos.y = y / gridsize;            // center coords            pos.x = pos.x * 2 - 1;            pos.y = pos.y * 2 - 1;            // which emotion is closer to this point and its distance            for (var i = 0; i < num_points; ++i) {                let dist = pos.distanceToSquared(valAroPoints[i]);                 if (dist > min_dist)                    continue;                nearest = i;                min_dist = dist;            }            values[2 * (x + y * gridsize)] = nearest;            values[2 * (x + y * gridsize) + 1] = min_dist;        }    return values;}FacialEmotion.prototype.initFaceValAro = function (faceData, shift) {    // Valence and arousal    //let valaro = faceData.valaro || [0.1, 0.1];    this.valaro = new THREE.Vector2().fromArray(faceData.valaro || [0.1, 0.1]);    if (faceData.emotion) {        switch (faceData.emotion) {            case "ANGER":                this.valaro.fromArray(this._pit[0].slice(0, 2));                break;            case "HAPPINESS":                this.valaro.fromArray(this._pit[1].slice(0, 2));                break;            case "SADNESS":                this.valaro.fromArray(this._pit[2].slice(0, 2));                break;            case "SURPRISE":                this.valaro.fromArray(this._pit[3].slice(0, 2));                break;            case "FEAR":                this.valaro.fromArray(this._pit[4].slice(0, 2));                break;            case "DISGUST":                this.valaro.fromArray(this._pit[5].slice(0, 2));                break;            case "CONTEMPT":                this.valaro.fromArray(this._pit[6].slice(0, 2));                break;            default: // "NEUTRAL"                this.valaro.fromArray(this._pit[7].slice(0, 2));                break;        }    }    // Normalize    let magn = this.valaro.length();    if ( magn > 1 ) {        this.valaro.x /= magn;        this.valaro.y /= magn;    }    // Sync    this.start = faceData.start || 0.0;    this.end = faceData.end;    this.amount = faceData.amount || 1.0;    if ( shift ) {        this.attackPeak = faceData.attackPeak || this.end;        this.relax = this.end = this.attackPeak + 1;//faceData.end || faceData.attackPeak || 0.0; // ignored "end" and "relax" on shift    } else {        this.attackPeak = faceData.attackPeak || (this.end - this.start) * 0.25 + this.start;        this.relax = faceData.relax || (this.end - this.attackPeak) / 2 + this.attackPeak;    }    this.amount = isNaN(faceData.amount) ? 1 : faceData.amount;    // Target blend shapes    this.VA2BSW(this.valaro, shift);    // Start    this.transition = true;    this.time = 0;}FacialEmotion.prototype.VA2BSW = function (valAro, shift) {    let gridsize = this.gridSize;    let blendValues = [];    blendValues.length = this._pit[0].length - 2;    blendValues.fill(0);    // position in grid to check    let pos = valAro.clone();    //precompute VA points weight in the grid    let values = this._precomputed_weights;    // one entry for each emotion    let weights = [];    weights.length = this._pit.length;    weights.fill(0);    let total_inside = 0;    let pos2 = new THREE.Vector2();     //for each position in grid, check if distance to pos is lower than distance to its nearest emotion    for (let y = 0; y < gridsize; ++y) {        for (let x = 0; x < gridsize; ++x) {            //normalize            pos2.x = x / gridsize;            pos2.y = y / gridsize;            //center            pos2.x = pos2.x * 2 - 1;            pos2.y = pos2.y * 2 - 1;            let data_pos = (x + y * gridsize) * 2; // two values in each entry            let point_index = values[data_pos];            let point_distance = values[data_pos + 1];            let is_inside = pos2.distanceToSquared(pos) < (point_distance + 0.001);//epsilon            if (is_inside) {                weights[point_index] += 1;                total_inside++;            }        }    }    // average each emotion with respect to amount of points near this.valAro    for (let i = 0; i < weights.length; ++i) {        weights[i] /= total_inside;        for (let j = 0; j < blendValues.length; j++) {            blendValues[j] += this._pit[i][j + 2] * weights[i];        }    }    // swap initial state and current state arrays    let temp = this.initialVABSW;    this.initialVABSW = this.currentVABSW; // set initial state as current state (it might be neutral or some other emotion that was cut mid transition)    this.currentVABSW = temp;    for (let j = 0; j < blendValues.length; j++) {        this.targetVABSW[j] = blendValues[j] * this.amount;        this.currentVABSW[j] = this.initialVABSW[j]; // initial and current should be the same        if ( shift ){ // change default pose if shift            this.defaultVABSW[j] = this.targetVABSW[j];         }    }}FacialEmotion.prototype.updateVABSW = function (dt) {    if( this.transition == false ){        for (let j = 0; j < this.currentVABSW.length; j++)            this.currentVABSW[j] = this.defaultVABSW[j];        return;    }        // Time increase    this.time += dt;    // Wait for to reach start time    if (this.time < this.start){        return;    }    // Stay still during attackPeak to relax    if (this.time > this.attackPeak && this.time < this.relax){        return;    }    // End    if (this.time >= this.end) {        for (let j = 0; j < this.currentVABSW.length; j++)            this.currentVABSW[j] = this.defaultVABSW[j];        this.transition = false;        return;    }    let inter = 0;    // Trans 1    if (this.time <= this.attackPeak) {        inter = (this.time - this.start) / (this.attackPeak - this.start);        // Cosine interpolation        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;        // Interpolation        for (let j = 0; j < this.targetVABSW.length; j++)            this.currentVABSW[j] = this.initialVABSW[j] * (1 - inter) + this.targetVABSW[j] * inter;        return;    }    // Trans 2    if (this.time > this.relax && this.time < this.end) {        inter = (this.time - this.relax) / (this.end - this.relax);        // Cosine interpolation        inter = Math.cos(Math.PI * inter) * 0.5 + 0.5;        // Interpolation        for (let j = 0; j < this.targetVABSW.length; j++)           this.currentVABSW[j] = this.defaultVABSW[j] * (1 - inter) + this.targetVABSW[j] * inter;        return;    }}// --------------------- GAZE (AND HEAD SHIFT DIRECTION) ---------------------// BML// <gaze or gazeShift start ready* relax* end influence target offsetAngle offsetDirection>// influence [EYES, HEAD, NECK, SHOULDER, WAIST, WHOLE, ...]// offsetAngle relative to target// offsetDirection (of offsetAngle) [RIGHT, LEFT, UP, DOWN, UPRIGHT, UPLEFT, DOWNLEFT, DOWNRIGHT]// target [CAMERA, RIGHT, LEFT, UP, DOWN, UPRIGHT, UPLEFT, DOWNLEFT, DOWNRIGHT]// Scene inputs: gazePositions (head and camera), lookAt objects// Gaze manager (replace BML)GazeManager.gazePositions = {       "RIGHT": new THREE.Vector3(30, 2, 100), "LEFT": new THREE.Vector3(-30, 2, 100),    "UP": new THREE.Vector3(0, 20, 100), "DOWN": new THREE.Vector3(0, -20, 100),    "UPRIGHT": new THREE.Vector3(30, 20, 100), "UPLEFT": new THREE.Vector3(-30, 20, 100),    "DOWNRIGHT": new THREE.Vector3(30, -20, 100), "DOWNLEFT": new THREE.Vector3(-30, -20, 100),    "FRONT": new THREE.Vector3(0, 2, 100), "CAMERA": new THREE.Vector3(0, 2, 100)};Gaze.prototype.gazeBS = {    "RIGHT": { squint: 0, eyelids: 0 }, "LEFT": { squint: 0, eyelids: 0 },    "UP": { squint: 0.3, eyelids: 0 }, "DOWN": { squint: 0, eyelids: 0.2 },    "UPRIGHT": { squint: 0.3, eyelids: 0 }, "UPLEFT": { squint: 0.3, eyelids: 0 },    "DOWNRIGHT": { squint: 0, eyelids: 0.2 }, "DOWNLEFT": { squint: 0, eyelids: 0.2 },    "FRONT": { squint: 0, eyelids: 0 }, "CAMERA": { squint: 0, eyelids: 0 }, "EYESTARGET": { squint: 0, eyelids: 0 }, "HEADTARGET": { squint: 0, eyelids: 0 }, "NECKTARGET": { squint: 0, eyelids: 0 }};// Constructor (lookAt objects and gazePositions)function GazeManager(lookAtNeck, lookAtHead, lookAtEyes, gazePositions = null) {        // Gaze positions    this.gazePositions = gazePositions || GazeManager.gazePositions;    // LookAt objects    this.lookAtNeck = lookAtNeck;    this.lookAtHead = lookAtHead;    this.lookAtEyes = lookAtEyes;    // Gaze Actions (could create here inital gazes and then recycle for memory efficiency)    this.gazeActions = [null, null, null]; // eyes, head, neck    this.gazeActions[0] = new Gaze(this.lookAtEyes, this.gazePositions, true);    this.gazeActions[1] = new Gaze(this.lookAtHead, this.gazePositions, false);    this.gazeActions[2] = new Gaze(this.lookAtNeck, this.gazePositions, false);}GazeManager.prototype.reset = function () {    this.lookAtNeck.position.set(0, 2.5, 100);    this.lookAtHead.position.set(0, 2.5, 100);    this.lookAtEyes.position.set(0, 2.5, 100);    this.gazeActions[0].transition = false;    this.gazeActions[1].transition = false;    this.gazeActions[2].transition = false;    this.gazeActions[0].eyelidsW = 0;    this.gazeActions[0].squintW = 0;}// gazeData with influence, sync attr, target, offsets...GazeManager.prototype.newGaze = function (gazeData, shift, gazePositions, headOnly) {    // Gaze positions    this.gazePositions = gazePositions || this.gazePositions;    // Influence check, to upper case    gazeData.influence = stringToUpperCase(gazeData.influence, "Gaze influence", "HEAD");    // NECK requires adjustment of HEAD and EYES    // HEAD requires adjustment of EYES    switch (gazeData.influence) {        case "NECK":            this.gazeActions[2].initGazeData(gazeData, shift);        case "HEAD":            this.gazeActions[1].initGazeData(gazeData, shift);        case "EYES":            if (!headOnly)                this.gazeActions[0].initGazeData(gazeData, shift);        default: break;    }}GazeManager.prototype.update = function (dt) {    // Gaze actions update    for (let i = 0; i < this.gazeActions.length; i++) {        // If gaze exists (could inizialize empty gazes)        if (this.gazeActions[i] && this.gazeActions[i].transition) {            this.gazeActions[i].update(dt);        }    }    return {        eyelids: this.gazeActions[0].eyelidsW,        squint: this.gazeActions[0].squintW    };}// --------------------- GAZE (AND HEAD SHIFT DIRECTION) ---------------------// Memory allocation of temporal arrays. Used only for some computations in initGazeValuesGaze.prototype._tempQ = new THREE.Quaternion();Gaze.prototype.targetP = new THREE.Vector3();// Constructorfunction Gaze(lookAt, gazePositions, isEyes = false) {    this.isEyes = isEyes;    // Gaze positions    if (gazePositions) {        this.gazePositions = gazePositions;    }    // Scene variables    this.cameraEye = gazePositions["CAMERA"] || new THREE.Vector3();    this.headPos = gazePositions["HEAD"] || new THREE.Vector3();    this.lookAt = lookAt;    // make it deactivated    this.transition = false;    this.eyelidsW = 0;    this.squintW = 0;}Gaze.prototype.initGazeData = function (gazeData, shift) {    // Sync    this.start = gazeData.start || 0.0;    this.end = gazeData.end || 2.0;    if (!shift) {        this.ready = gazeData.ready || this.start + (this.end - this.start) / 3;        this.relax = gazeData.relax || this.start + 2 * (this.end - this.start) / 3;    } else {        this.ready = this.end;        this.relax = 0;    }    // Offset direction    this.offsetDirection = stringToUpperCase(gazeData.offsetDirection, "Gaze offsetDirection", "RIGHT");    // Target    this.target = stringToUpperCase(gazeData.target, "Gaze target", "FRONT");    // Angle    this.offsetAngle = gazeData.offsetAngle || 0.0;    // Start    this.transition = true;    this.time = 0;    // Extension - Dynamic    this.dynamic = gazeData.dynamic || false;    //Blendshapes    this.eyelidsW = 0;    this.eyelidsInitW = 0;    this.eyelidsFinW = gazeData.eyelidsWeight || this.gazeBS[this.target].eyelids;    this.squintW = gazeData.squintWeight || 0;    this.squintInitW = gazeData.squintWeight || 0;    this.squintFinW = gazeData.squintWeight || this.gazeBS[this.target].squint;    // Define initial values    this.initGazeValues();}Gaze.prototype.update = function (dt) {    // Time increase    this.time += dt;    // Wait for to reach start time    if (this.time < this.start)        return;    // Stay still during ready to relax    if (this.time > this.ready && this.time < this.relax)        return;    // Extension - Dynamic (offsets do not work here)    if (this.dynamic) {        this.EndP.copy(this.gazePositions[this.target]);    }    // transition 1 and 2    if (this.time <= this.end) {        let inter = 0;        if (this.time <= this.ready) { inter = (this.time - this.start) / (this.ready - this.start); } // trans 1        else { inter = 1 - (this.time - this.relax) / (this.end - this.relax); }  // trans 2        // Cosine interpolation        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;        if (this.isEyes) {            this.eyelidsW = this.eyelidsInitW * (1 - inter) + this.eyelidsFinW * (inter);            this.squintW = this.squintInitW * (1 - inter) + this.squintFinW * (inter);        }        // lookAt pos change        this.lookAt.position.lerpVectors(this.InP, this.EndP, inter);        //this.lookAt.mustUpdate = true;        return;    }    // End    if (this.time > this.end) {        // Extension - Dynamic        if (this.dynamic) {            this.lookAt.position.copy(this.EndP);        }        else {            this.transition = false;            this.eyelidsW = this.eyelidsInitW;            this.squintW = this.squintInitW;        }    }}Gaze.prototype.initGazeValues = function () {    // Find target position (copy? for following object? if following object and offsetangle, need to recalculate all the time!)    if (this.gazePositions && this.gazePositions[this.target]) {        this.targetP.copy(this.gazePositions[this.target]);    } else {        this.targetP.set(0, 110, 100);    }    // Angle offset    // Define offset angles (respective to head position?)    // Move to origin    let q = this._tempQ;    let v = this.targetP.sub(this.headPos);    let magn = v.length();    v.normalize();    this.eyelidsFinW = this.gazeBS[this.target].eyelids;    this.squintFinW = this.gazeBS[this.target].squint;    // Rotate vector and reposition    switch (this.offsetDirection) {        case "UPRIGHT":            q.setFromAxisAngle(v, -25 * DEG2RAD);            v.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.offsetAngle * DEG2RAD);            v.applyQuaternion(q);            if (this.isEyes) {                this.squintFinW *= Math.abs(this.offsetAngle / 30)            }            break;        case "UPLEFT":            q.setFromAxisAngle(v, -75 * DEG2RAD);            v.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.offsetAngle * DEG2RAD);            v.applyQuaternion(q);            if (this.isEyes) {                this.squintFinW *= Math.abs(this.offsetAngle / 30)            }            break;        case "DOWNRIGHT":            q.setFromAxisAngle(v, -25 * DEG2RAD);            v.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.offsetAngle * DEG2RAD);            v.applyQuaternion(q);            if (this.isEyes) {                this.eyelidsFinW *= Math.abs(this.offsetAngle / 30)            }            break;        case "DOWNLEFT":            q.setFromAxisAngle(v, 75 * DEG2RAD);            v.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.offsetAngle * DEG2RAD);            v.applyQuaternion(q);            if (this.isEyes) {                this.eyelidsFinW *= Math.abs(this.offsetAngle / 30)            }            break;        case "RIGHT":            v.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.offsetAngle * DEG2RAD);            break;        case "LEFT":            v.applyAxisAngle(new THREE.Vector3(0, 1, 0), -this.offsetAngle * DEG2RAD);            break;        case "UP":            v = new THREE.Vector3(1, 0, 0);            q.setFromAxisAngle(v, -45 * DEG2RAD);            v.applyAxisAngle(new THREE.Vector3(1, 0, 0), this.offsetAngle * DEG2RAD);            v.applyQuaternion(q);            if (this.isEyes) {                this.squintFinW *= Math.abs(this.offsetAngle / 30)            }            break;        case "DOWN":            /* quat.setAxisAngle(q, v, 45*DEG2RAD);//quat.setAxisAngle(q, v, 90*DEG2RAD);             vec3.rotateY(v,v, this.offsetAngle*DEG2RAD);             vec3.transformQuat(v,v,q);*/            // let c = v.clone();            // c.cross(new THREE.Vector3(0,1,0));            // let q = new THREE.Quaternion();            // q.setFromAxisAngle(c, this.offsetAngle*DEG2RAD)            // //q.setFromAxisAngle(new, 0)//45*DEG2RAD);            // //c.applyAxisAngle(c, this.offsetAngle*DEG2RAD);            // v.applyQuaternion(q);            // v.normalize()            if (this.isEyes) {                this.eyelidsFinW *= Math.abs(this.offsetAngle / 30)            }            break;    }        // Move to head position and save modified target position    v.addScaledVector(v, magn);    v.addVectors(v, this.headPos);    this.targetP.copy(v)    if (!this.lookAt || !this.lookAt.position)        return console.log("ERROR: lookAt not defined ", this.lookAt);    // Define initial and end positions    this.InP = this.lookAt.position.clone();    this.EndP = this.targetP.clone(); // why copy? targetP shared with several?}// --------------------- HEAD ---------------------// BML// <head start ready strokeStart stroke strokeEnd relax end lexeme repetition amount>// lexeme [NOD, SHAKE, TILT, TILTLEFT, TILTRIGHT, TILTFORWARD, TILTBACKWARD, FORWARD, BACKWARD]// repetition cancels stroke attr// amount how intense is the head nod? 0 to 1// head nods will go slightly up -> position = ready&stroke_start and stroke_end&relax// Should work together with gaze. Check how far is from the top-bottom angle limits or right-left angle limits// Scene inputs: head bone node, neutral rotation and lookAtComponent rotation// Combination of gaze and lookAtComponent://if (this.headBML.transition){//  this._lookAtHeadComponent.applyRotation = false;//  this.headBML.update(dt);//} else//  this._lookAtHeadComponent.applyRotation = true;// Constructor// headNode is to combine gaze rotations and head behaviorfunction HeadBML(headData, headNode, lookAtRot, limVert, limHor) {    // Rotation limits (from lookAt component for example)    this.limVert = Math.abs(limVert) || 20;    this.limHor = Math.abs(limHor) || 30;    // Scene variables    this.headNode = headNode;    this.lookAtRot = new THREE.Quaternion(lookAtRot.x, lookAtRot.y, lookAtRot.z, lookAtRot.w);    // Init variables    this.initHeadData(headData);}// Init variablesHeadBML.prototype.initHeadData = function (headData) {        // start -> ready -> strokeStart -> stroke -> strokeEnd -> relax -> end    headData.lexeme = stringToUpperCase(headData.lexeme, "Head lexeme", "NOD");    // Lexeme, repetition and amount    this.lexeme = headData.lexeme || "NOD";    this.amount = headData.amount || 0.2;    // Maximum rotation amplitude    if (this.lexeme == "NOD" || this.lexeme == "TILTLEFT" || this.lexeme == "TILTRIGHT" || this.lexeme == "TILTFORWARD" || this.lexeme == "TILTBACKWARD" || this.lexeme == "FORWARD" || this.lexeme == "BACKWARD")        this.maxDeg = this.limVert * 2;    else        this.maxDeg = this.limHor * 2;    // Sync start ready strokeStart stroke strokeEnd relax end    this.start = headData.start || 0;    this.end = headData.end || 2.0;    this.ready = headData.ready || headData.strokeStart || (this.end / 4);    this.relax = headData.relax || headData.strokeEnd || (this.end * 3 / 4);    this.strokeStart = headData.strokeStart || this.ready;    this.strokeEnd = headData.strokeEnd || this.relax;    this.repetition = (isNaN(headData.repetition)) ? 0 : Math.abs(headData.repetition);    this.repeatedIndx = 0;    // Modify stroke and strokeEnd with repetition    this.strokeEnd = this.strokeStart + (this.strokeEnd - this.strokeStart) / (1 + this.repetition)    this.stroke = (this.strokeStart + this.strokeEnd) / 2;    // Start    this.transition = true;    this.phase = 0;    this.time = 0;    this.currentAngle = 0;    // Define initial values    this.initHeadValues();}HeadBML.prototype.initHeadValues = function () {    // Head initial rotation    this.inQ = this.headNode.quaternion.clone();    // Compare rotations to know which side to rotate    // Amount of rotation    var neutralInv = this.lookAtRot.clone().invert();    var rotAmount = neutralInv.clone();    rotAmount.multiply(this.inQ);    var eulerRot = new THREE.Euler().setFromQuaternion(rotAmount);    // X -> right(neg) left(pos)    // Z -> up(neg) down(pos)    // in here we choose which side to rotate and how much according to limits    // the lookAt component should be stopped here (or set to not modify node, only final lookAt quat output)    this.strokeAxis = new THREE.Vector3(1, 0, 0);    this.strokeDeg = 0; // degrees of stroke    this.readyDeg = 0; // ready will have some inertia in the opposite direction of stroke     switch ( this.lexeme ) {        case "NOD":            // nod will always be downwards            this.strokeAxis.set(1, 0, 0);            this.strokeDeg = this.amount * this.maxDeg;            this.readyDeg = this.strokeDeg * 0.5;            // If the stroke rotation passes the limit, change readyDeg            if (eulerRot.z * RAD2DEG + this.strokeDeg > this.limVert)                this.readyDeg = this.strokeDeg - this.limVert + eulerRot.z * RAD2DEG;            break;                case "SHAKE":            this.strokeAxis.set(0, 1, 0);            this.strokeDeg = this.amount * this.maxDeg;            this.readyDeg = this.strokeDeg * 0.5;            // Sign (left rigth)            this.RorL = Math.sign(eulerRot.y) ? Math.sign(eulerRot.y) : 1;            this.readyDeg *= -this.RorL;            this.strokeDeg *= -this.RorL;            break;            case "TILT":            this.strokeAxis.set(0, 0, 1);            this.strokeDeg = this.amount * 20;            this.readyDeg = this.strokeDeg * 0.5;            break;        case "TILTLEFT":            this.strokeAxis.set(0, 0, 1);            this.strokeDeg = this.amount * this.maxDeg;            this.readyDeg = this.strokeDeg * 0.8;            if(!this.repetition) {                                this.strokeStart = this.ready;                this.strokeEnd = this.relax;            }            break;        case "TILTRIGHT":            this.strokeAxis.set(0, 0, -1);            this.strokeDeg = this.amount * this.maxDeg;            this.readyDeg = this.strokeDeg * 0.8;            if(!this.repetition) {                                this.strokeStart = this.ready;                this.strokeEnd = this.relax;            }            break;                case "TILTFORWARD":            this.strokeAxis.set(-1, 0, 0);            this.strokeDeg = this.amount * this.maxDeg;            this.readyDeg = this.strokeDeg * 0.8;            if(!this.repetition) {                                this.strokeStart = this.ready;                this.strokeEnd = this.relax;            }            break;        case "TILTBACKWARD":            this.strokeAxis.set(1, 0, 0);            this.strokeDeg = this.amount * this.maxDeg;            this.readyDeg = this.strokeDeg * 0.8;            if(!this.repetition) {                                this.strokeStart = this.ready;                this.strokeEnd = this.relax;            }            break;                    case "FORWARD":            // nod will always be downwards            this.strokeAxis.set(-1, 0, 0);            this.strokeDeg = this.amount * this.maxDeg ;            this.readyDeg = this.strokeDeg * 0.8;            if(!this.repetition) {                                this.strokeStart = this.ready;                this.strokeEnd = this.relax;            }            break;        case "BACKWARD":            // nod will always be downwards            this.strokeAxis.set(1, 0, 0);            this.strokeDeg = this.amount *  this.maxDeg;            this.readyDeg = this.strokeDeg * 0.8;            if(!this.repetition) {                                this.strokeStart = this.ready;                this.strokeEnd = this.relax;            }            break;    }    this.currentStrokeQuat = new THREE.Quaternion(); this.currentStrokeQuat.setFromAxisAngle(this.strokeAxis, 0); // current state of rotation}HeadBML.prototype.update = function (dt) {    // Time increase    this.time += dt;    let inter = 0;    // Wait for to reach start time    if (this.time < this.start)        return;    // Repetition -> Redefine strokeStart, stroke and strokeEnd before update    if (this.time < this.relax && this.time >= this.strokeEnd && this.repeatedIndx < this.repetition) {        this.repeatedIndx++;        let timeRep = (this.strokeEnd - this.strokeStart);        this.strokeStart = this.strokeEnd;        this.strokeEnd += timeRep;        this.stroke = (this.strokeEnd + this.strokeStart) / 2;        this.phase = 0;    }    // Ready    if (this.time <= this.ready) {        inter = (this.time - this.start) / (this.ready - this.start);        // Cosine interpolation        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;        this.currentAngle = -this.readyDeg * inter;        this.currentStrokeQuat.setFromAxisAngle(this.strokeAxis, this.currentAngle * DEG2RAD);    }    // StrokeStart    else if (this.time > this.ready && this.time < this.strokeStart) {        return;    }    // Stroke (phase 1)    else if (this.time >= this.strokeStart && this.time <= this.stroke ) {        inter = (this.time - this.strokeStart) / (this.stroke - this.strokeStart);        // Cosine interpolation        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;        if (this.phase != 1 ) {            if(this.repeatedIndx >= this.repetition && this.lexeme != "TILT" && this.lexeme != "NOD" && this.lexeme != "SHAKE" )                return;            this.phase = 1;        }        this.currentAngle = -this.readyDeg + inter * this.strokeDeg;        this.currentStrokeQuat.setFromAxisAngle(this.strokeAxis, this.currentAngle * DEG2RAD);    }    // Stroke (phase 2)    else if (this.time > this.stroke && this.time <= this.strokeEnd && this.repeatedIndx < this.repetition) {        inter = (this.time - this.stroke) / (this.strokeEnd - this.stroke);        // Cosine interpolation        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;        if (this.phase != 2) {            this.phase = 2;        }        this.currentAngle = -this.readyDeg + ( 1 - inter ) * this.strokeDeg;        this.currentStrokeQuat.setFromAxisAngle(this.strokeAxis, this.currentAngle * DEG2RAD);    }       // StrokeEnd (no repetition)    else if (this.time >= this.strokeEnd && this.time < this.relax) {        return;    }    // Relax -> Move towards lookAt final rotation    else if (this.time > this.relax && this.time <= this.end) {        inter = (this.time - this.relax) / (this.end - this.relax);        // Cosine interpolation        inter = Math.cos(Math.PI * inter + Math.PI) * 0.5 + 0.5;        this.currentStrokeQuat.setFromAxisAngle(this.strokeAxis, (1-inter) * this.currentAngle * DEG2RAD);    }    // End    else if (this.time > this.end) {        this.currentStrokeQuat.set(0,0,0,1);        this.transition = false        return;    }}// Turn to upper case and error checkvar stringToUpperCase = function (item, textItem, def) {    // To upper case    if (Object.prototype.toString.call(item) === '[object String]')        return item.toUpperCase();    else { // No string        //console.warn(textItem + " not defined properly.", item);        return def;    }}// --------------------- LIPSYNC MODULE --------------------// Switch to https if using this scriptif (window.location.protocol != "https:")    window.location.href = "https:" + window.location.href.substring(window.location.protocol.length);// // Audio context// if (!Lipsync.AContext)// Lipsync.AContext = new AudioContext();// Audio sourcesLipsync.prototype.refFBins = [0, 500, 700, 3000, 6000];// Constructorfunction Lipsync(threshold, smoothness, pitch) {    // Freq analysis bins, energy and lipsync vectors    this.energy = [0, 0, 0, 0, 0, 0, 0, 0];    this.BSW = [0, 0, 0]; //kiss,lipsClosed,jaw    // Lipsync parameters    this.threshold = threshold || 0.0;    this.dynamics = 30;    this.maxDB = -30;    this.smoothness = smoothness || 0.6;    this.pitch = pitch || 1;    // Change freq bins according to pitch    this.fBins = [];    this.defineFBins(this.pitch);    // Initialize buffers    this.init();    // Output .csv (debug)    //this.outstr = "time, e0, e1, e2, e3, bs_kiss, bs_lips_closed, bs_jaw\n";    this.working = false;}// Start mic inputLipsync.prototype.start = function (URL) {    // Audio context    if (!Lipsync.AContext)        Lipsync.AContext = new AudioContext();    // Restart    this.stopSample();    thatLip = this;    if (URL === undefined) {        /* navigator.getUserMedia({audio: true}, function(stream) {          thatLip.stream = stream;          thatLip.sample = thatLip.context.createMediaStreamSource(stream);          thatLip.sample.connect(thatLip.analyser);          console.log("Mic sampling rate:", thatLip.context.sampleRate);          thatLip.analyser.disconnect();          thatLip.gainNode.disconnect();          thatLip.working = true;        }, function(e){console.error("ERROR: get user media: ", e);});*/    } else {        this.loadSample(URL);    }}Lipsync.prototype.loadBlob = function (blob) {    // Audio context    if (Lipsync.AContext)        Lipsync.AContext.resume();    const fileReader = new FileReader()    // Set up file reader on loaded end event    fileReader.onloadend = () => {        const arrayBuffer = fileReader.result;        var that = this;        this.context.decodeAudioData(arrayBuffer,            function (buffer) {                //LGAudio.cached_audios[URL] = buffer;                that.stopSample();                that.sample = Lipsync.AContext.createBufferSource();                that.sample.buffer = buffer;                console.log("Audio loaded");                that.playSample();            }, function (e) { console.log("Failed to load audio"); });    };    //Load blob    fileReader.readAsArrayBuffer(getBlobURL(blob))}Lipsync.prototype.loadSample = function (inURL) {        var URL = LS.RM.getFullURL(inURL);    if (LGAudio.cached_audios[URL] && URL.indexOf("blob:") == -1) {        this.stopSample();        this.sample = Lipsync.AContext.createBufferSource();        this.sample.buffer = LGAudio.cached_audios[URL];        this.playSample();    } else {        var request = new XMLHttpRequest();        request.open('GET', URL, true);        request.responseType = 'arraybuffer';        var that = this;        request.onload = function () {            that.context.decodeAudioData(request.response,                function (buffer) {                    LGAudio.cached_audios[URL] = buffer;                    that.stopSample();                    that.sample = Lipsync.AContext.createBufferSource();                    that.sample.buffer = buffer;                    console.log("Audio loaded");                    that.playSample();                }, function (e) { console.log("Failed to load audio"); });        };        request.send();    }}Lipsync.prototype.playSample = function () {    // Sample to analyzer    this.sample.connect(this.analyser);    // Analyzer to Gain    this.analyser.connect(this.gainNode);    // Gain to Hardware    this.gainNode.connect(this.context.destination);    // Volume    this.gainNode.gain.value = 1;    console.log("Sample rate: ", this.context.sampleRate);    var that = this;    this.working = true;    this.sample.onended = function () { that.working = false; };    // start    this.sample.start(0);    //this.sample.loop = true;    // Output stream (debug)    //this.timeStart = thiscene.time;    //this.outstr = "time, e0, e1, e2, e3, bs_kiss, bs_lips_closed, bs_jaw\n";}// Update lipsync weightsLipsync.prototype.update = function () {    if (!this.working)        return;    // FFT data    if (!this.analyser) {        //if (this.gainNode){        // Analyser        this.analyser = this.context.createAnalyser();        // FFT size        this.analyser.fftSize = 1024;        // FFT smoothing        this.analyser.smoothingTimeConstant = this.smoothness;        //}        //else return;    }    // Short-term power spectrum    this.analyser.getFloatFrequencyData(this.data);    // Analyze energies    this.binAnalysis();    // Calculate lipsync blenshape weights    this.lipAnalysis();}Lipsync.prototype.stop = function (dt) {        // Immediate stop    if (dt === undefined) {        // Stop mic input        this.stopSample();        this.working = false;    }    // Delayed stop    else {        thatLip = this;        setTimeout(thatLip.stop.bind(thatLip), dt * 1000);    }}// Define fBinsLipsync.prototype.defineFBins = function (pitch) {        for (var i = 0; i < this.refFBins.length; i++)        this.fBins[i] = this.refFBins[i] * pitch;}// Audio buffers and analysersLipsync.prototype.init = function () {    // Audio context    if (!Lipsync.AContext)        Lipsync.AContext = new AudioContext();    var context = this.context = Lipsync.AContext;    // Sound source    this.sample = context.createBufferSource();    // Gain Node    this.gainNode = context.createGain();    // Analyser    this.analyser = context.createAnalyser();    // FFT size    this.analyser.fftSize = 1024;    // FFT smoothing    this.analyser.smoothingTimeConstant = this.smoothness;    // FFT buffer    this.data = new Float32Array(this.analyser.frequencyBinCount);}// Analyze energiesLipsync.prototype.binAnalysis = function () {    // Signal properties    var nfft = this.analyser.frequencyBinCount;    var fs = this.context.sampleRate;    var fBins = this.fBins;    var energy = this.energy;    // Energy of bins    for (var binInd = 0; binInd < fBins.length - 1; binInd++) {        // Start and end of bin        var indxIn = Math.round(fBins[binInd] * nfft / (fs / 2));        var indxEnd = Math.round(fBins[binInd + 1] * nfft / (fs / 2));        // Sum of freq values        energy[binInd] = 0;        for (var i = indxIn; i < indxEnd; i++) {            // Power Spectogram            //var value = Math.pow(10, this.data[i]/10);            // Previous approach            var value = 0.5 + (this.data[i] + 20) / 140;            if (value < 0) value = 0;            energy[binInd] += value;        }        // Divide by number of sumples        energy[binInd] /= (indxEnd - indxIn);        // Logarithmic scale        //energy[binInd] = 10*Math.log10(energy[binInd] + 1E-6);        // Dynamic scaling        //energy[binInd] = ( energy[binInd] - this.maxDB)/this.dynamics + 1 - this.threshold;    }}// Calculate lipsyncBSWLipsync.prototype.lipAnalysis = function () {    var energy = this.energy;    if (energy !== undefined) {        var value = 0;        // Kiss blend shape        // When there is energy in the 1 and 2 bin, blend shape is 0        value = (0.5 - (energy[2])) * 2;        if (energy[1] < 0.2)            value = value * (energy[1] * 5)        value = Math.max(0, Math.min(value, 1)); // Clip        this.BSW[0] = value;        // Lips closed blend shape        value = energy[3] * 3;        value = Math.max(0, Math.min(value, 1)); // Clip        this.BSW[1] = value;        // Jaw blend shape        value = energy[1] * 0.8 - energy[3] * 0.8;        value = Math.max(0, Math.min(value, 1)); // Clip        this.BSW[2] = value;    }}// Stops mic inputLipsync.prototype.stopSample = function () {        // If AudioBufferSourceNode has started    if (this.sample)        if (this.sample.buffer)            this.sample.stop(0);    // If microphone input    if (this.stream) {        var tracks = this.stream.getTracks();        for (var i = 0; i < tracks.length; i++)            if (tracks[i].kind = "audio")                tracks[i].stop();        this.stream = null;    }}function getBlobURL(arrayBuffer) {    var i, l, d, array;    d = arrayBuffer;    l = d.length;    array = new Uint8Array(l);    for (var i = 0; i < l; i++) {        array[i] = d.charCodeAt(i);    }    var b = new Blob([array], { type: 'application/octet-stream' });    // let blob = blobUtil.arrayBufferToBlob(arrayBuffer, "audio/wav")    return b}// ------------------------ TEXT TO LIP --------------------------------------------function Text2LipInterface() {        let _ = new Text2Lip();    this.start = _.start.bind( _ );    this.stop = _.stop.bind( _ );    this.pause = _.pause.bind( _ );    this.resume = _.resume.bind( _ );    this.update = _.update.bind( _ );    this.setEvent = _.setEvent.bind( _ );    this.setTables = _.setTables.bind( _ );    this.setDefaultSpeed = _.setDefaultSpeed.bind( _ );    this.setDefaultIntensity = _.setDefaultIntensity.bind( _ );    this.setSourceBSWValues = _.setSourceBSWValues.bind( _ );    this.getDefaultSpeed = _.getDefaultSpeed.bind( _ );    this.getDefaultIntensity = _.getDefaultIntensity.bind( _ );    this.getCurrentIntensity = _.getCurrentIntensity.bind( _ );    this.getSentenceDuration = _.getSentenceDuration.bind( _ ); // THE ONLY REASON THIS IS NOT STATIC IS BECAUSE IT USES this.DEFAULT_SPEED       this.cleanQueueSentences = _.cleanQueueSentences.bind( _ );    this.pushSentence = _.pushSentence.bind( _ );    this.getBSW = function () { return _.BSW; }    this.getCompactState = _.getCompactState.bind( _ );    this.isWorking = _.isWorking.bind( _ );    this.isPaused = _.isPaused.bind( _ );    this.needsSentences = _.needsSentences.bind( _ );    this.getNumSentences = _.getNumSentences.bind( _ );    this.getMaxNumSentences = _.getMaxNumSentences.bind( _ );}function Text2Lip() {        this.DEFAULT_SPEED = 8; // phonemes/s    this.DEFAULT_INTENSITY = 0.5; // [0,1]    // tables ( references )    this.lowerBoundVisemes = null;    this.upperBoundVisemes = null;    this.coarts = null;    this.ph2v = null;    this.numShapes = 0;    // manages display of a sentence    this.working = false;    this.paused = false;    this.speed = this.DEFAULT_SPEED; // phonemes/s    this.intensity = this.DEFAULT_INTENSITY; // [0,1]    this.text = "";    this.currTargetIdx = 0; // current target character (aka when t=1 during interpolation, this char is shown)    this.currT = 0; // current time of interpolation    this.useCoarticulation = true;    this.delay = 0;    // variables for managing list of sentences to display    this.currSent = null;    this.queueIdx = 0;    this.queueSize = 0;    this.sentenceQueue = new Array( Text2Lip.QUEUE_MAX_SIZE );    this.sentenceIDCount = 1; // when pushing, a 0 will mean failure. Start IDs at 1    // blendshape weights. User can use this to do mouthing    this.BSW = new Float32Array( this.numShapes ); this.BSW.fill( 0 );    // needed because of coarticulation    this.currV = new Float32Array( this.numShapes ); this.currV.fill( 0 );    this.targV = new Float32Array( this.numShapes ); this.targV.fill( 0 ); // next visem - target    // event listeners    this.onIdle = null;    this.onSentenceEnd = null; // receives ended sentence    this.onSentenceStart = null; // receives starting sentence    // default setup    this.setTables( T2LTABLES.PhonemeToViseme, T2LTABLES.Coarticulations, T2LTABLES.LowerBound, T2LTABLES.UpperBound );}Text2Lip.prototype.setDefaultSpeed = function ( speed ) {    if ( typeof ( speed ) === 'number' && speed > 0.001 ) {        this.DEFAULT_SPEED = speed;        return true;    }    return false;};Text2Lip.prototype.setDefaultIntensity = function ( intensity ) {    if ( typeof ( intensity ) === 'number' ) {        this.DEFAULT_INTENSITY = Math.max( 0.0, Math.min( 1.0, intensity ) );        return true;    }    return false;};Text2Lip.prototype.setSourceBSWValues = function ( values ) {    // values is only a number    if ( typeof ( values ) == "number" ) {        for ( let i = 0; i < this.currV.length; ++i ) {            this.currV[ i ] = values;        }        return;    }    // values is an array    for ( let i = 0; i < this.BSW.length && i < values.length; ++i ) {        let value = ( typeof ( values[ i ] ) == "number" ) ? values[ i ] : 0.0;        this.currV[ i ] = value;    }}Text2Lip.prototype.setEvent = function ( eventType, fun ) {    if ( typeof ( fun ) !== 'function' ) { return false; }    switch ( eventType ) {        case "onIdle": this.onIdle = fun; break;        case "onSentenceEnd": this.onSentenceEnd = fun; break;        case "onSentenceStart": this.onSentenceStart = fun; break;        default: return false;    }    return true;}Text2Lip.prototype.setTables = function ( phonemeToViseme, coarts, lowerBoundVisemes, upperBoundVisemes = null ) {    this.lowerBoundVisemes = lowerBoundVisemes;    this.upperBoundVisemes = ( upperBoundVisemes && upperBoundVisemes.length > 0 ) ? upperBoundVisemes : lowerBoundVisemes;    this.coarts = coarts;    this.ph2v = phonemeToViseme;    this.numShapes = 0    if ( lowerBoundVisemes && lowerBoundVisemes.length > 0 ) {        this.numShapes = lowerBoundVisemes[ 0 ].length;    }    this.BSW = new Float32Array( this.numShapes ); this.BSW.fill( 0 );    this.currV = new Float32Array( this.numShapes ); this.currV.fill( 0 );    this.targV = new Float32Array( this.numShapes ); this.targV.fill( 0 ); // next visem - target}Text2Lip.prototype.getDefaultSpeed = function () { return this.DEFAULT_SPEED; }Text2Lip.prototype.getDefaultIntensity = function () { return this.DEFAULT_INTENSITY; }Text2Lip.prototype.getCurrentIntensity = function () { return this.getIntensityAtIndex( this.currTargetIdx ); }Text2Lip.prototype.getIntensityAtIndex = function ( index ) {    if ( this.currSent ) {        if ( index >= 0 && index < this.currSent.text.length ) {            let phInt = this.currSent.phInt;            if ( phInt && index < phInt.length ) { return phInt[ index ]; }            else if ( this.currSent.sentInt !== null ) { return this.currSent.sentInt; }        }    }    return this.DEFAULT_INTENSITY;}/*** * @param {*} phoneme * @param {Array} outResult if not null, result will be written to this array. Otherwise a new array is generated with the resulting values and returned * @returns returns outResult or a new Float32Array*/Text2Lip.prototype.getViseme = function ( phoneme, outResult = null, ) {    // this handles properly undefined and nulls.    if ( !( phoneme in this.ph2v ) ) { return this.lowerBoundVisemes[ 0 ]; } // assuming there are visemes    let visIdx = this.ph2v[ phoneme ];    if ( visIdx < 0 || visIdx >= this.lowerBoundVisemes.length ) { return this.lowerBoundVisemes[ 0 ]; } // assuming there are visemes    let lower = this.lowerBoundVisemes[ visIdx ];    let upper = this.upperBoundVisemes[ visIdx ];    let result = ( outResult ) ? outResult : ( new Float32Array( this.numShapes ) );    let intensity = this.intensity;    for ( let i = 0; i < this.numShapes; i++ ) {        result[ i ] = lower[ i ] * ( 1 - intensity ) + upper[ i ] * intensity;    }    return result;}/*** * @param {*} phoneme * @returns returns a reference to the coart entry*/Text2Lip.prototype.getCoarts = function ( phoneme ) {    // this handles properly undefined and nulls.    if ( !( phoneme in this.ph2v ) ) { return this.coarts[ 0 ]; } // assuming there are coarts    let visIdx = this.ph2v[ phoneme ];    if ( visIdx < 0 || visIdx >= this.coarts.length ) { return this.coarts[ 0 ]; } // assuming there are visemes    return this.coarts[ visIdx ];}/*** * @param {*} phoneme * @param {*} phonemeAfter * @param {*} outResult  if not null, result will be written to this array. Otherwise a new array is generated with the resulting values and returned * @returns returns outResult or a new Float32Array*/Text2Lip.prototype.getCoarticulatedViseme = function ( phoneme, phonemeAfter, outResult = null ) {    let rawTarget = this.getViseme( phoneme );    let coartsW = this.getCoarts( phoneme ); // coarticulation weights of target phoneme    //let visemePrev = this.currV; // phoneme before target    let visemeAfter = this.getViseme( phonemeAfter ); // phoneme after target    let result = ( outResult ) ? outResult : ( new Float32Array( this.numShapes ) );    for ( let i = 0; i < this.numShapes; ++i ) {        result[ i ] = ( 1.0 - coartsW[ i ] ) * rawTarget[ i ] + coartsW[ i ] * visemeAfter[ i ]//(0.2 * visemePrev[i] + 0.8 * visemeAfter[i]);    }    return result;}// constantText2Lip.QUEUE_MAX_SIZE = 32;Text2Lip.prototype.start = function () {    this.stop( false );    this.working = true;    this.paused = false;    this.changeCurrentSentence( false );}Text2Lip.prototype.pause = function () { this.paused = this.working; } // can only be paused if workingText2Lip.prototype.resume = function () { this.paused = false; }/*** stops update. No sentence is modified. However some variables are reseted, meaning the sentence being displayed currently will start from the beginning * if a start is called* To completely clean the queue, call cleanQueueSentences or pass true as argument* @param {Bool} cleanQueue if true, all pending sentences are cleared and will not be displayed. */Text2Lip.prototype.stop = function ( cleanQueue = false ) {    this.working = false;    this.paused = false;    this.currTargetIdx = 0; // for a smooth intro    this.currT = 0;    this.BSW.fill( 0 );    this.currV.fill( 0 );    this.targV.fill( 0 );    if ( !!cleanQueue ) // force to be boolean        this.cleanQueueSentences();}/*** returns a number * Bit 0: set when module is not working ( stopped )* Bit 1: set when module is working but paused* Bit 2: set when module does not have more sentences to compute. If working, it is idle, waiting for some push* if the entire value is 0, the module is actively working* @returns */Text2Lip.prototype.getCompactState = function () {    let result = !this.working;    result |= this.paused << 1;    result |= ( !this.queueSize ) << 2;    return result;}Text2Lip.prototype.isWorking = function () { return this.working; }Text2Lip.prototype.isPaused = function () { return this.paused; }Text2Lip.prototype.needsSentences = function () { return !this.queueSize; }Text2Lip.prototype.getNumSentences = function () { return this.queueSize; }Text2Lip.prototype.getMaxNumSentences = function () { return Text2Lip.QUEUE_MAX_SIZE; }Text2Lip.prototype.update = function ( dt ) {    if ( !this.working || this.paused || !this.currSent ) { return; }    // check for sentence delay    if ( this.delay > 0.001 ) {        this.delay -= dt;        if ( this.delay >= 0.0 ) {            return;        }        dt = -this.delay;        this.delay = 0;        if ( dt < 0.001 ) return;    }    let durations = this.currSent.phT;    let invSpeed = 1.0 / this.speed; // seconds / phoneme    this.currT += dt;    let p = 0;    let t = 0;    let useGeneralSpeed = true; // when durations array ends, it should continue with general speed    // use specific phoneme durations    if ( durations && this.currTargetIdx < durations.length ) {        useGeneralSpeed = false;        let durationIdx = this.currTargetIdx;        while ( durationIdx < durations.length && durations[ durationIdx ] < this.currT ) {            this.currT -= Math.max( 0.001, durations[ durationIdx ] );            durationIdx++;            p++;        }        useGeneralSpeed = durationIdx >= durations.length; // durations array has ended. Check general speed        this.currT = Math.max( 0, this.currT ); // just in case        t = ( durationIdx < durations.length ) ? ( this.currT / durations[ durationIdx ] ) : Math.max( 0.0, Math.min( 1.0, this.currT * this.speed ) ); // after phoneme ease-in, t will be clamped to 1 until phoneme change        this.currTargetIdx = durationIdx;    }    // no more specific phoneme durations and there is enough time to check     if ( useGeneralSpeed ) {        // use temporal p variable to avoid overwriting durations array result        let general_p = Math.floor( this.currT * this.speed ); // complete phonemes         t = ( this.currT * this.speed ) - general_p;  // remaining piece of phoneme, used on interpolation        this.currT -= general_p * invSpeed;        this.currTargetIdx += general_p;        p += general_p;    }    // t function modifier;    //t = 0.5* Math.sin( t * Math.PI - Math.PI * 0.5 ) +0.5; // weird on slow phonemes    // phoneme changed    if ( p > 0 ) {        // copy target values to source Viseme. Several phonemes may have passed during this frame. Take the last real target phoneme        let lastPhonemeIndex = Math.max( 0.0, Math.min( this.text.length - 1, this.currTargetIdx - 1 ) ); // currTargetIdx here is always > 0. text.length here is always > 0        this.intensity = this.getIntensityAtIndex( lastPhonemeIndex ); // get last real target viseme with correct intensity, in case more than 1 phoneme change in the same frame        let lastPhoneme = this.text[ lastPhonemeIndex ];                    if ( this.useCoarticulation ){            let lastPhonemeNext = ( lastPhonemeIndex == ( this.text.length - 1 ) ) ? null : ( this.text[ lastPhonemeIndex + 1 ] );            this.getCoarticulatedViseme( lastPhoneme, lastPhonemeNext, this.currV );        }        else{            this.getViseme( lastPhoneme, this.currV );        }        // end of sentence reached        if ( this.currTargetIdx >= this.text.length ) {            for ( let i = 0; i < this.numShapes; ++i ) { this.BSW[ i ] = this.currV[ i ]; } // currV holds the last real target phoneme            this.changeCurrentSentence();            return;        }        this.intensity = this.getIntensityAtIndex( this.currTargetIdx ); // get intensity for next target        if ( !this.useCoarticulation ) {            this.getViseme( this.text[ this.currTargetIdx ], this.targV );        }        else {            let targetPhoneme = this.text[ this.currTargetIdx ];            let targetPhonemeNext = ( this.currTargetIdx == ( this.text.length - 1 ) ) ? null : this.text[ this.currTargetIdx + 1 ];            this.getCoarticulatedViseme( targetPhoneme, targetPhonemeNext, this.targV );        }    }    // final interpolation    let BSW_0 = this.currV;    let BSW_1 = this.targV;    for ( let i = 0; i < this.numShapes; ++i ) {        this.BSW[ i ] = ( 1.0 - t ) * BSW_0[ i ] + t * BSW_1[ i ];    }}Text2Lip.prototype.cleanQueueSentences = function () {    this.queueIdx = 0;    this.currSent = null;    this.queueSize = 0;    this.sentenceQueue.fill( null );}/*** sets all necessary parameters for the sentence indicated by queueIdx (if any).  * @param {Bool} advanceIndex before setting paramters, index of sentence is incremented and amoun of sentences reduced, discarding the previous sentence* @returns */Text2Lip.prototype.changeCurrentSentence = function ( advanceIndex = true ) {    if ( advanceIndex ) { // when executing start(), do not advance         --this.queueSize;        this.sentenceQueue[ this.queueIdx ] = null; // dereference obj        this.queueIdx = ( this.queueIdx + 1 ) % Text2Lip.QUEUE_MAX_SIZE;        // end events        if ( this.currSent && this.onSentenceEnd ) { this.onSentenceEnd( this.currSent ); }        if ( this.currSent.onEndEvent ) { this.currSent.onEndEvent(); }    }    if ( this.queueSize <= 0 ) {        this.currT = 0;        this.cleanQueueSentences();        if ( this.onIdle ) { this.onIdle(); }        return;    }    // parameters setup    this.currSent = this.sentenceQueue[ this.queueIdx ];    this.text = this.currSent.text;    this.speed = this.currSent.speed;    this.delay = this.currSent.delay;    this.useCoarticulation = this.currSent.useCoart;    this.currTargetIdx = 0;    if ( !advanceIndex ) { this.currT = 0; } // reset timer only if called from start. Otherwise keep remaining time from previous sentence    // target first phoneme    this.intensity = this.getIntensityAtIndex( this.currTargetIdx ); // get target viseme with correct intensity    if ( this.useCoarticulation ) {        let targetPhoneme = this.text[ 0 ];        let targetPhonemeNext = ( this.text.length > 1 ) ? this.text[ 1 ] : null;        this.getCoarticulatedViseme( targetPhoneme, targetPhonemeNext, this.targV );    }    else {        this.getViseme( this.text[ 0 ], this.targV );    }    // Start events    if ( this.onSentenceStart ) { this.onSentenceStart( this.currSent ); } // generic start event    if ( this.currSent.onStartEvent ) { this.currSent.onStartEvent(); }     // sentence specifici start event}/*** Adds sentence to the queue.WARNING!!!Each sentence will have a smooth intro and outro. (from neutral to phoneme and from phoneme to neutral pose)   - Intro time DOES NOT have to be accounted for on any timing   - Outro time HAVE to be accounted for timings. If not included in sentT, the system will use default phoneme speed to transition to neutral. sentT should take it into accountAny value below 0.001 will be ignored.* @param {string/array} text string of phonemes to display * @param {object} options object containing any of the optional string of phonemes to display.* @param {Float32Array} phT (Optional) timing for each phoneme. Overrides sentT, speed and default speed.* @param {Number} sentT (Optional): Number, timing (in seconds) of whole string. Overrides default speed and speed argument. Delay not included. Defaults to null.* @param {Number} speed (Optional) phonemes/s of whole string. Overrides default speed. Delay not included.* @param {Float32Array} phInt (Optional) intensity for each phoneme. Overrides sentInt and default intensity.* @param {Number} sentInt (Optional) intensity of whole string. Overrides default intensity. Delay not included.* @param {Boolean} useCoart (Optional) use coarticulation. Default to true.* @param {Number} delay (Optional) delay to start playing this string. Delay starts at the end of the sentence it is being played now. If none, delay starts immediately.* @param {Boolean} copyArrays (Optional) Whether to create new arrays and copy values or directly use the reference sent as argument. Defaults to false (only reference is used).* @param {Boolean} outro (Optional) Whether to automatically include a final "." into the string to end in neutral pose. Defaults to false.* @param {Function} onStartEvent (Optional) when sentence starts, this event is called after the generic onSentenceStart event.* @param {Function} onEndEvent (Optional) when sentence ends, this event is called after the generic onSentenceEnd event.* @returns the id number of the sentence if successful. 0 otherwise.*/Text2Lip.prototype.pushSentence = function ( text, options = {} ) {    let phT = options.phT;    let sentT = options.sentT;    let speed = options.speed;    let phInt = options.phInt;    let sentInt = options.sentInt;    let delay = options.delay;    let outro = options.outro;    let useCoart = options.useCoart;    let copyArrays = options.copyArrays;    let onEndEvent = options.onEndEvent;    let onStartEvent = options.onStartEvent;    if ( this.queueSize === Text2Lip.QUEUE_MAX_SIZE ) { return null; }    if ( !text || !text.length ) { return null; }    // clean input    if ( !( phT instanceof Float32Array ) ) phT = null;    if ( !( phInt instanceof Float32Array ) ) phInt = null;    if ( copyArrays ) {        text = Array.from( text ); // create new array from        if ( phT ) {            let temp = new Float32Array( phT.length );            temp.set( phT );            phT = temp;        }        if ( phInt ) {            let temp = new Float32Array( phInt.length );            temp.set( phInt );            phInt = temp;        }    }    // put outro     if ( !!outro ) {        if ( typeof ( text ) === 'string' ) { text = text + "."; }        else { text.push( "." ); }    }    if ( text.length < 0 ) { return null; }    let sentenceSpeed = this.DEFAULT_SPEED;    if ( typeof ( speed ) === 'number' && !isNaN( speed ) && speed >= 0.001 ) { sentenceSpeed = speed; }    if ( typeof ( sentT ) === 'number' && !isNaN( sentT ) && sentT >= 0.001 ) { sentenceSpeed = text.length / sentT; }    if ( typeof ( delay ) !== 'number' || isNaN( delay ) || delay < 0 ) { delay = 0; }    if ( typeof ( useCoart ) === 'undefined' ) { useCoart = true; } useCoart = !!useCoart;    if ( !( onEndEvent instanceof Function ) ) { onEndEvent = null; }    if ( !( onStartEvent instanceof Function ) ) { onStartEvent = null; }    if ( typeof ( sentInt ) !== 'number' || isNaN( sentInt ) ) { sentInt = null; } // this allows for changing intensity while mouthing through setDefaulIntensity    else { sentInt = Math.max( 0.0, Math.min( 1.0, sentInt ) ); }    let id = this.sentenceIDCount++;    let totalTime = this.getSentenceDuration( text, options ); // doing work twice, though...    let sentenceObj = {        id: id,        totalTime: totalTime,        text: text,        phT: phT,        speed: sentenceSpeed,        phInt: phInt,        sentInt: sentInt,        useCoart: useCoart,        delay: delay,        onStartEvent: onStartEvent,        onEndEvent: onEndEvent,    }    let indexPos = ( this.queueIdx + this.queueSize ) % Text2Lip.QUEUE_MAX_SIZE;    this.sentenceQueue[ indexPos ] = sentenceObj; // only reference is copied    this.queueSize++;    // when working but idle because of no sentences, automatically play this new sentence    if ( this.working && this.queueSize == 1 ) {        this.changeCurrentSentence( false );    }    return { id: id, totalTime: totalTime };};/*** Send the same info you would send to pushSentence.* @param {string/array} text * @param {object} options * @returns in seconds*/Text2Lip.prototype.getSentenceDuration = function ( text, options ) {    // THE ONLY REASON THIS IS NOT STAIC IS BECAUSE IT USES this.DEFAULT_SPEED       let phT = options.phT;    let sentT = options.sentT;    let speed = options.speed;    let delay = options.delay;    let outro = options.outro;    if ( !text || !text.length ) { return 0; }    if ( !( phT instanceof Float32Array ) ) phT = null;    let textLength = text.length;    if ( !!outro ) { textLength++; }    let sentenceSpeed = this.DEFAULT_SPEED;    if ( typeof ( speed ) === 'number' && !isNaN( speed ) && speed >= 0.001 ) sentenceSpeed = speed;    if ( typeof ( sentT ) === 'number' && !isNaN( sentT ) && sentT >= 0.001 ) sentenceSpeed = textLength / sentT;    if ( typeof ( delay ) !== 'number' || isNaN( delay ) || delay < 0 ) delay = 0;    let totalTime = 0;    totalTime += delay;    if ( phT ) {        let validEntries = ( phT.length >= textLength ) ? textLength : phT.length;        for ( let i = 0; i < validEntries; ++i ) { totalTime += Math.max( phT[ i ], 0.001 ); }        textLength -= validEntries;    }    // use sentence speed to compute time of phonemes with no phT    totalTime += textLength * ( 1.0 / sentenceSpeed );    return totalTime;}// TABLES ------------------------------//[ "kiss", "upperLipClosed", "lowerLipClosed", "jawOpen", "tongueFrontUp", "tongueBackUp", "tongueOut" ],let t2lLowerBound = [  [ 0,     0,     0,     0,     0,     0,     0   ], // 0  [ 0,     0,     0,     0,     0,     0,     0   ],  [ 0.1,   0.15,  0,     0.2,   0,     0,     0   ],  [ 0.0,   0.13,  0,     0.2,   0.2,   0,     0   ],  [ 0,     0.08,  0,     0.1,   0.5,   0.5,   0   ], // 4  [ 0.25,  0.15,  0.15,  0.2,   0,     0,     0   ],  [ 0.35,  0.15,  0.15,  0.2,   0,     0,     0   ],  [ 0.0,   0.15,  0,     0.1,   1,     0,     0   ],  [ 0,     0.5,   0.2,   0.1,   0,     0,     0   ], // 8  [ 0,     0.0,   0.2,   0.1,   0,     0,     0   ],  [ 0.15,  0,     0,     0.13,  0.8,   0,     0   ],  [ 0.0,   0,     0,     0.2,   0.0,   0.3,   0   ],  [ 0.0,   0,     0,     0.1,   0.0,   1,     0   ], // 12  [ 0.3,   0,     0,     0.1,   1,     0,     0   ],  [ 0,     0,     0.0,   0.1,   0.35,  0,     0.3 ],  [ 0.3,   0,     0,     0.13,   0.8,   0,     0   ],];let t2lUpperBound = [  [ 0,     0,     0,     0,     0,     0,     0   ], // 0  [ 0,     0,     0,     0,     0,     0,     0   ],   [ 0.1,   0.15,  0,     0.6,   0,     0,     0   ],  [ 0.0,   0.13,  0,     0.3,   0.2,   0,     0   ],  [ 0,     0.08,  0,     0.2,   0.6,   0.6,   0.2 ], // 4  [ 0.45,  0.15,  0.15,  0.6,   0,     0,     0   ],  [ 0.85,  0.3,   0.3,   0.3,   0,     0,     0   ],  [ 0.0,   0.15,  0,     0.4,   1,     0,     0.5 ],  [ 0,     1,     1,     0.4,   0,     0,     0   ], // 8  [ 0,     0.0,   1,     0.4,   0,     0,     0   ],  [ 0.15,  0,     0,     0.13,  0.8,   0,     0   ],  [ 0.0,   0,     0,     0.4,   0.0,   0.3,   0   ],  [ 0.1,   0,     0,     0.2,   0.0,   1,     0   ], // 12  [ 0.3,   0,     0,     0.22,  1,     0,     0   ],  [ 0,     0,     0.0,   0.4,   0.55,  0,     0.8 ],  [ 0.3,   0,     0,     0.13,  0.8,   0,     0   ],];// coarticulation weights for each phoneme. 0= no modification to phoneme, 1=use phonemes arround to build visemelet t2lCoarts = [  [ 0,     0,     0,     0,     0,     0,     0   ], // 0  [ 0.6,   0.6,   0.6,   0.6,   0.6,   0.6,   0.6 ],  [ 0.2,   0.3,   0.3,   0.3,   0.1,   0.3,   0.5 ],  [ 0.0,   0.3,   0.3,   0.3,   0.1,   0.3,   0.5 ],  [ 0.1,   0.3,   0.3,   0.3,   0,     0,     0.5 ], // 4  [ 0.2,   0.3,   0.3,   0.3,   0.3,   0.3,   0.5 ],  [ 0.2,   0.3,   0.3,   0.3,   0.3,   0.3,   0.5 ],  [ 1,     0.4,   0.4,   0.9,   0,     0.5,   0.5 ],  [ 1,     0,     0,     0.2,   1,     0.8,   0.5 ], //8   [ 1,     0,     0,     0.2,   1,     0.5,   0.5 ],  [ 1,     0.6,   0.6,   0.6,   0,     0.5,   0.5 ],  [ 1,     1,     1,     0.7,   0.5,   0.5,   0.5 ],  [ 0.7,   0.5,   0.5,   0.9,   0.6,   0,     0.5 ], //12  [ 1,     1,     1,     0.5,   0,     0,     0.5 ],  [ 1,     0.3,   0.3,   0.3,   0,     0.6,   0   ],   [ 0.5,   0.3,   0.3,   0.5,  0,     0,     0    ],];let t2lPh2v = {    ".": 0, "_": 1, " ": 1,    "a": 2,//"AA"	     "@": 2,//"AE"	     "A": 2,//"AH"	     "c": 5,//"AO"	     "W": 2,//"AW"	     "x": 2,//"AX"	     "Y": 2,//"AY"	     "E": 3,//"EH"	     "R": 3,//"ER"	     "e": 3,//"EY"	     "I": 4,//"IH"	     "X": 4,//"IX"	     "i": 4,//"IY"	     "o": 5,//"OW"	     "O": 5,//"OY"	     "U": 6,//"UH"	     "u": 6,//"UW"	     "b": 8,//"B"	    "C": 15,//"CH"	 // ------------------------ Really needs a new viseme - 'SH'    "d": 13,//"D"	    "D": 13,//"DH"	    "F": 13,//"DX"	    "L": 7,//"EL"	    "M": 8,//"EM"	    "N": 7,//"EN"	    "f": 9,//"F"	    "g": 12,//"G"	    "h": 11,//"H"	// reduced    "J": 15,//"JH"	 // ------------------------- Really needs a new viseme 'ZH'    "k": 12,//"K"	    "l": 7,//"L"	    "m": 8,//"M"	    "n": 7,//"N"	    "G": 12,//"NG"	// reduced    "p": 8,//"P"	    "Q": 2,//"Q"	 // -------------------------- What is this?    "r": 7,//"R"	    "s": 10,//"S"	    "S": 15,//"SH"	 // ------------------------ Really needs a new viseme - 'CH'    "t": 13,//"T"	    "T": 14,//"TH"	    "v": 9,//"V"	    "w": 6,//"W"	    "H": 6,//"WH"	    "y": 4,//"Y"	    "z": 10,//"Z"	    "Z": 10,//"ZH"	 // ------------------------- Really needs a new viseme 'JH'};let T2LTABLES = {    BlendshapeMapping: { kiss: 0, upperLipClosed: 1, lowerLipClosed: 2, jawOpen: 3, tongueFrontUp: 4, tongueBackUp: 5, tongueOut: 6 },    LowerBound: t2lLowerBound,    UpperBound: t2lUpperBound,    Coarticulations: t2lCoarts,    PhonemeToViseme : t2lPh2v,}/* ANIMATION */AnimationManager.prototype.animations = {    "IDLE": "evalls/projects/animations/animations_idle.wbin",    "WAVE": "evalls/projects/animations/animations_waving.wbin",    "NO": "evalls/projects/animations/animations_no.wbin",    "BORED": "evalls/projects/animations/animations_bored.wbin",    "ANGRY": "evalls/projects/animations/animations_angry.wbin",    "HAPPY": "evalls/projects/animations/animations_happy.wbin",    "PRAYING": "evalls/projects/animations/animations_praying.wbin",    "CRAZY": "evalls/projects/animations/animations_crazy.wbin"}function AnimationManager(component, animations) {    this.animManager = component;    // Animations    this.animations = animations || this.animations;    this.playing = false;}// animationData with animationID, sync attr, speedAnimationManager.prototype.newAnimation = function (animationData, animations) {        this.currentAnim = {        speed: this.animManager.playback_speed,        animation: this.animManager.animation    }    this.playing = false;    // Sync    this.start = animationData.start || 0.0;    this.speed = animationData.speed || 1.0;    this.shift = animationData.shift;    this.time = 0;    var url = this.animations[animationData.name];    this.animationName = url;    var anim = LS.RM.getResource(this.animationName)    if (!anim)        LS.RM.load(this.animationName, null, this.setDuration.bind(this))    else        this.setDuration(anim)}AnimationManager.prototype.initValues = function () {        this.time = 0;}AnimationManager.prototype.setDuration = function (anim) {        this.duration = anim.takes.default.duration;}AnimationManager.prototype.update = function (dt) {    if (this.time == 0)        this.initValues();    // Wait for to reach start time    if (this.time < this.start) {        return;    }    else if (this.time >= this.start && !this.playing) {        this.animManager.playback_speed = this.speed;        this.animManager.animation = this.animationName;        this.playing = true;    }    else if (!this.shift && this.time >= this.duration && this.playing) {        this.animManager.animation = this.currentAnim.animation;        this.animManager.playback_speed = this.currentAnim.speed;    }    this.time += dt;}
// convert rotation names into radiants. 'u' and 'ur' are extremes. By setting them to 160 and -135, the interpolation of quaternion choses the correct interpolation path. Otherwise it rotates on the wrong directionlet extfidirPointTable = {    'u'     : new THREE.Vector3(  0,   1,   0 ),       'ul'    : new THREE.Vector3(  1,   1,   0 ),       'l'     : new THREE.Vector3(  1,   0,   0 ),       'dl'    : new THREE.Vector3(  1,   -1,   0 ),       'd'     : new THREE.Vector3(  0,   -1,   0 ),       'dr'    : new THREE.Vector3( -1,   -1,   0 ),      'r'     : new THREE.Vector3( -1,   0,   0 ),      'ur'    : new THREE.Vector3( -1,   1,   0 ),      "uo"    : new THREE.Vector3(  0,   1,   1 ),    "uol"   : new THREE.Vector3(  1,   1,   1 ),    "ol"    : new THREE.Vector3(  1,   0,   1 ),    "dol"   : new THREE.Vector3(  1,   -1,   1 ),    "do"    : new THREE.Vector3(  0,   -1,   1 ),    "dor"   : new THREE.Vector3( -1,   -1,   1 ),    "or"    : new THREE.Vector3( -1,   0,   1 ),    "uor"   : new THREE.Vector3( -1,   1,   1 ),    "o"     : new THREE.Vector3(  0,   0,   1 ),        "ui"    : new THREE.Vector3(  0,   1,   -1 ),    "uil"   : new THREE.Vector3(  1,   1,   -1 ),    "il"    : new THREE.Vector3(  1,   0,   -1 ),    "dil"   : new THREE.Vector3(  1,   -1,   -1 ),    "di"    : new THREE.Vector3(  0,   -1,   -1 ),    "dir"   : new THREE.Vector3( -1,   -1,   -1 ),    "ir"    : new THREE.Vector3( -1,   0,   -1 ),    "uir"   : new THREE.Vector3( -1,   1,   -1 ),    "i"     : new THREE.Vector3(  0,   0,   -1 ),}// receives bml instructions and animates the wrists. Swing rotation only class Extfidir {    constructor( boneMap, skeleton, isLeftHand = false ){        this.skeleton = skeleton;        this.mirror = !!isLeftHand;        let handName = ( isLeftHand ) ? "L" : "R";        let bones = this.skeleton.bones;        this.idx = boneMap[ handName + "Wrist" ]; // wrist index        this.wristBone = bones[ this.idx ];        this.twistAxis = ( new THREE.Vector3() ).copy( bones[ boneMap[ handName + "HandMiddle" ] ].position ).normalize();        this.leftAxis = ( new THREE.Vector3() ).subVectors(             isLeftHand ? bones[ boneMap[ handName + "HandRing" ] ].position : bones[ boneMap[ handName + "HandIndex" ] ].position,             isLeftHand ? bones[ boneMap[ handName + "HandIndex" ] ].position : bones[ boneMap[ handName + "HandRing" ] ].position ).normalize();        this.upAxis = ( new THREE.Vector3() ).crossVectors( this.twistAxis, this.leftAxis ).normalize(); // compute Y        this.leftAxis.crossVectors( this.upAxis, this.twistAxis ).normalize(); // compute X                this.defPoint = new THREE.Vector3();        this.trgPoint = new THREE.Vector3();         // no defG  = new THREE.Quaternion. Will reuse srcG and trgG during relax-end        this.trgG = new THREE.Quaternion();        this.srcG = new THREE.Quaternion();        this.curG = new THREE.Quaternion();                // when extfidir is "inwards", the "l" and "r" are swapped. Make the change gradually        this.srcPalmorRefactor = 1;        this.trgPalmorRefactor = 1;        this.curPalmorRefactor = 1;        this.defPalmorRefactor = 1;                // when positioning the hand "outwards down", there might be some twist needed for the forearm.        this.foreArmCorrectionAngle = 0;                        this.reset();                this.time = 0; // current time of transition        this.start = 0;        this.attackPeak = 0;        this.relax = 0;         this.end = 0;        this.transition = false;        this._tempMat4_0 = new THREE.Matrix4();        this._tempV3_0 = new THREE.Vector3(); // world pos and cross products        this._tempV3_1 = new THREE.Vector3(); // z axis        this._tempV3_2 = new THREE.Vector3(); // x axis        this._tempV3_3 = new THREE.Vector3(); // y axis        this._tempQ_0 = new THREE.Quaternion();    }    reset() {        // Force pose update to flat        this.transition = false;        this.defPoint.copy( extfidirPointTable[ 'o' ] );        this.defPalmorRefactor = 1;        this.curG.copy( extfidirPointTable[ 'o' ] );        this.curPalmorRefactor = 1;        this.foreArmCorrectionAngle = 0;    }        _computeSwingFromCurrentPose( targetPoint, resultWristQuat ){        //targetPoint must be normalized        // if ( mode == EXTFIDIR_MODES.RELATIVE ){ // center rotation points on wrist ( wristWorldPos + targetPoint )            this._computeRelative( targetPoint, resultWristQuat );        // }         // else{ // EXTFIDIR_MODES.LOCAL        //     this.foreArmCorrectionAngle = 0;        //     let elevation = Math.atan2( targetPoint.y, Math.sqrt( targetPoint.x * targetPoint.x + targetPoint.z * targetPoint.z ) );        //     let bearing = Math.atan2( targetPoint.x, targetPoint.z );        //     resultWristQuat.setFromAxisAngle( this.leftAxis, -elevation );        //     this._tempQ_0.setFromAxisAngle( this.upAxis, bearing );        //     resultWristQuat.premultiply( this._tempQ_0 );        // }    }      // compute the swing rotation so as to get the twistAxis to point at a certain location. It finds the forearm twist correction      _computeRelative( targetPoint, resultWristQuat ){        let elevation = Math.atan2( targetPoint.y, Math.sqrt( targetPoint.x * targetPoint.x + targetPoint.z * targetPoint.z ) );        let bearing = Math.atan2( targetPoint.x, targetPoint.z );                // this solves ir        if ( this.mirror ){             if ( bearing > 1.58825 ){ bearing -= Math.PI * 2; }         }         else {            if ( bearing < -1.58825 ){ bearing += Math.PI * 2; }         }        let wristBone = this.wristBone;        wristBone.quaternion.set(0,0,0,1); // swing computation requires it to be with no palmor        wristBone.updateWorldMatrix( true );        let invWorld = this._tempMat4_0;        invWorld.copy( wristBone.matrixWorld );        invWorld.invert();        let wristWorldPos = this._tempV3_0;        wristWorldPos.setFromMatrixPosition( wristBone.matrixWorld );                let worldZAxisToLocal = this._tempV3_1.set(0,0,10000);        worldZAxisToLocal.add(wristWorldPos);        worldZAxisToLocal.applyMatrix4( invWorld );        worldZAxisToLocal.normalize();                let worldXAxisToLocal = this._tempV3_2.set(10000,0,0);        worldXAxisToLocal.add( wristWorldPos );        worldXAxisToLocal.applyMatrix4( invWorld );        worldXAxisToLocal.normalize();                let worldYAxisToLocal = this._tempV3_3.crossVectors( worldZAxisToLocal, worldXAxisToLocal ).normalize();                // make hand point out in world coordinates ( +Z )        let angle = Math.acos( this.twistAxis.dot( worldZAxisToLocal ) );        let rotAx = this._tempV3_0;        rotAx.crossVectors( this.twistAxis, worldZAxisToLocal );        rotAx.normalize();        resultWristQuat.setFromAxisAngle( rotAx, angle );        // adjust hand orientation so it is facing down in world coordinates        let newLeftAxis = this._tempV3_0.copy( this.leftAxis ).applyQuaternion( resultWristQuat );        angle = Math.acos( newLeftAxis.dot( worldXAxisToLocal ) );        rotAx.crossVectors( newLeftAxis, worldXAxisToLocal ); // should be worldZAxis, but sign might differ        rotAx.normalize();        this._tempQ_0.setFromAxisAngle( rotAx, angle );        resultWristQuat.premultiply( this._tempQ_0 );        this.foreArmCorrectionAngle = angle * ( worldZAxisToLocal.dot( rotAx ) < 0 ? -1 : 1 );                // now, add extfidir                let elevationRot = this._tempQ_0.setFromAxisAngle( worldXAxisToLocal, -elevation ); // -elevation because of the axis vs atan        resultWristQuat.premultiply( elevationRot );        let bearingRot = this._tempQ_0.setFromAxisAngle( worldYAxisToLocal, bearing );        resultWristQuat.premultiply( bearingRot );    }    update( dt ) {        if ( !this.transition ){ return; } // no animation required                this.time += dt;        // wait in same pose        if ( this.time < this.start ){ this.curPalmorRefactor = this.srcPalmorRefactor; return; }        if ( this.time > this.attackPeak && this.time < this.relax ){             this._computeSwingFromCurrentPose( this.trgPoint, this.trgG ); // trgG update needed for relax-end            this.curG.copy( this.trgG );            this.curPalmorRefactor = this.trgPalmorRefactor;            return;         }                if ( this.time <= this.attackPeak ){            let t = ( this.time - this.start ) / ( this.attackPeak - this.start );            if ( t > 1){ t = 1; }            t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;            this._computeSwingFromCurrentPose( this.trgPoint, this.trgG );            nlerpQuats( this.curG, this.srcG, this.trgG, t );            // this.curG.slerpQuaternions( this.srcG, this.trgG, t ); // slerp performs worse than nlerp for some reason (about appearance, not hardware performance)            this.curPalmorRefactor = this.srcPalmorRefactor * (1-t) + this.trgPalmorRefactor * t;            return;        }        if ( this.time < this.end ){            let t = ( this.time - this.relax ) / ( this.end - this.relax );            if ( t > 1){ t = 1; }            t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;            this._computeSwingFromCurrentPose( this.defPoint, this.srcG );             nlerpQuats( this.curG, this.trgG, this.srcG, t ); // reusing srcG as defG            // this.curG.slerpQuaternions( this.trgG, this.srcG, t ); // slerp performs worse than nlerp for some reason (about appearance, not hardware performance)            this.curPalmorRefactor = this.trgPalmorRefactor * (1-t) + this.defPalmorRefactor * t;            return;        }                // local extfidir does not require constant update        if ( this.time >= this.end ){             this._computeSwingFromCurrentPose( this.defPoint, this.curG );            this.curPalmorRefactor = this.defPalmorRefactor;        }    }    /**     * bml info     * start, attackPeak, relax, end     * extfidir: string from extfidirPointTable     * secondExtfidir: (optional) string from extfidirPointTable. Will compute midpoint between extifidir and secondExtfidir     * mode: (optional) number or string - whether the pointing is to "absolute" (1), "relative" (2) or "local" (3) positions to the wrist       */    newGestureBML( bml, symmetry = false ){        if( !bml.extfidir ){ return; }              let extfidir = bml.extfidir;        let secondExtfidir = bml.secondExtfidir;        if ( extfidir && symmetry ){ extfidir = directionStringSymmetry( extfidir, symmetry ); }        if ( secondExtfidir && symmetry ){ secondExtfidir = directionStringSymmetry( secondExtfidir, symmetry ); }        let point = extfidirPointTable[ extfidir ];        if( !point ){             console.warn( "Gesture: Extfidir incorrect direction \"" + extfidir + "\"" );            return;         }                let secondPoint = extfidirPointTable[ secondExtfidir ];        if( !secondPoint ){             secondPoint = point;         }                // set source pose swing quaternions        this.srcG.copy( this.curG );        // compute midpoint between primary and secondary extfidir        this.trgPoint.lerpVectors( point, secondPoint, 0.5 );        this.trgPalmorRefactor = this.trgPoint.z < 0 ? -1 : 1;        this.srcPalmorRefactor = this.curPalmorRefactor;        // set defualt point if necessary        if( bml.shift ){            this.defPoint.copy( this.trgPoint );            this.defPalmorRefactor = this.trgPalmorRefactor;        }                // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;                 this.transition = true;    }}
// selected fingers available for mainblend: 0=Not selected, otherwise selected. 1=raw mainblend, 2=mainblend in thumb combinations (hamnosys)// Array of fingers 0=thumb 1=index 2=middle, 3=ring, 4=pinky// Four values per finger (0=splay, 1=base, 2=mid, 3=tip)let handShapes = {    // raw handshapes    fist:           { selected:[0,0,0,0,0], shape:[ [-1,0.3,0,0], [0,1,1,1], [0,1,1,1], [0,1,1,1], [0,1,1,1] ] },    finger2:        { selected:[0,1,0,0,0], shape:[ [1,1,0.6,0.5], [0,0,0,0], [0,1,1,1], [0,1,1,1], [0,1,1,1] ] },    finger23:       { selected:[0,1,1,0,0], shape:[ [1,1,0.6,0.5], [0,0,0,0], [0,0,0,0], [0,1,1,1], [0,1,1,1] ] },    finger23spread: { selected:[0,1,1,0,0], shape:[ [1,1,0.6,0.5], [0.8,0,0,0], [-0.2,0,0,0], [0,1,1,1], [0,1,1,1] ] },    finger2345:     { selected:[0,1,1,1,1], shape:[ [-1,0.3,0,0], [0.8,0,0,0], [0,0,0,0], [0.8,0,0,0], [0.8,0,0,0] ] },     flat:           { selected:[0,1,1,1,1], shape:[ [-1,0.3,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0] ] },    // thumb combinations - could be reduced to only pinch. Cee are basically pinch but with selected fingers open    pinch12:     { selected:[2,2,0,0,0], shape:[ [1,0.5,0.25,0.5], [0,0.3,0.8,0.25], [0,1,1,1], [0,1,1,1], [0,1,1,1] ] },    pinch12open: { selected:[2,2,0,0,0], shape:[ [1,0.5,0.25,0.5], [0,0.3,0.8,0.25], [0, 0.4, 0.2, 0.2], [0, 0.2, 0.2, 0.2], [0, 0, 0.2, 0.2] ] },    pinchall:    { selected:[2,2,2,2,2], shape:[ [1, 0.8, 0.4, 0.6], [0, 0.6, 0.6, 0.8], [0, 0.4, 0.6, 0.6], [0, 0.4, 0.7, 0.4], [0, 0.7, 0.5, 0.5] ] },    cee12:       { selected:[2,2,0,0,0], shape:[ [1, 0.5, 0.1, 0.2], [0, 0.15, 0.4, 0.6], [0,1,1,1], [0,1,1,1], [0,1,1,1] ] },    cee12open:   { selected:[2,2,0,0,0], shape:[ [1, 0.5, 0.1, 0.1], [0, 0.4, 0.5, 0.2], [0, 0.4, 0.2, 0.2], [0, 0.2, 0.2, 0.2], [0, 0, 0.2, 0.2] ] },    ceeall:      { selected:[2,2,2,2,2], shape:[ [1, 0.7, 0.1, 0.2], [0, 0.4, 0.2, 0.2], [0, 0.4, 0.2, 0.2], [0, 0.4, 0.2, 0.2], [0, 0.4, 0.2, 0.2] ], } };let thumbShapes = {    default:  [-1,0.3,0,0],    touch:  [-1,0.3,0,0],    out:    [0, -0.3, 0, 0],    opposed: [1, 1, 0, 0],    across: [1,1,0.6,0.5],     // across: [-0.5,0.7,0.7,1], }/* bending Mode:    1 - all fingers use the same parameters    2 - bending on a thumb combination. t= thumb, f=rest of fingers */let handBendings = {    straight: { 1: [0,0,0], 2:{ t:[0,0,0], f:[0,0,0] } },     halfbent: { 1: [0.5,0,0], 2:{ t:[8/9,0,0], f:[0.5,0,0] } },     bent:     { 1: [1,0,0], 2:{ t:[8/9,0,0], f:[1,0,0] } },     round:    { 1: [0.5,0.5,0.5], 2:{ t:[4/9,3/9,4/9], f:[5/9,6/9,9/9] } },     hooked:   { 1: [0,1,1], 2:{ t:[8/9,1/9,8/9], f:[9/9,6/9,6/9] } },     dblbent:  { 1: [1,1,0], 2:{ t:[8/9,1/9,8/9], f:[9/9,6/9,6/9] } },     dblhooked:{ 1: [1,1,1], 2:{ t:[8/9,1/9,8/9], f:[9/9,6/9,6/9] } },     }// probably could be computed through skeleton raw positionslet avatarHandAxes = {    "R" : {         "bends": [            (new THREE.Vector3(0,-1,-0.3)).normalize(), // thumb base            (new THREE.Vector3(0,-1,-0.3)).normalize(),            (new THREE.Vector3(0,-1,-0.3)).normalize(),            (new THREE.Vector3(1,0, -0.2)).normalize(), // index base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(), // middle base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0, 0.1)).normalize(), // ring base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0, 0.2)).normalize(), // pinky base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),        ],        "splays": [            (new THREE.Vector3(1,0,0)).normalize(), // thumb            (new THREE.Vector3(0,1,0)).normalize(),            (new THREE.Vector3(0,1,0)).normalize(),            (new THREE.Vector3(0,1,0)).normalize(),            (new THREE.Vector3(0,1,0)).normalize(), // pinky        ]    },    "L" : {         "bends": [            (new THREE.Vector3(0,1,0.3)).normalize(), // thumb base            (new THREE.Vector3(0,1,0.3)).normalize(),            (new THREE.Vector3(0,1,0.3)).normalize(),            (new THREE.Vector3(1,0, 0.2)).normalize(), // index base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(), // middle base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0, -0.1)).normalize(), // ring base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0, -0.2)).normalize(), // pinky base            (new THREE.Vector3(1,0,0)).normalize(),            (new THREE.Vector3(1,0,0)).normalize(),        ],        "splays": [            (new THREE.Vector3(1,0,0)).normalize(), // thumb            (new THREE.Vector3(0,-1,0)).normalize(),            (new THREE.Vector3(0,-1,0)).normalize(),            (new THREE.Vector3(0,-1,0)).normalize(),            (new THREE.Vector3(0,-1,0)).normalize(), // pinky        ]    }}let _tempHandQuat = new THREE.Quaternion(0,0,0,1);class HandShapeRealizer {    constructor( boneMap, skeleton, isLeftHand = false ){        this.skeleton = skeleton;        this.mirror = !!isLeftHand;        let handName = ( this.mirror ) ? "L" : "R";        this.idxs = { // base bone indexes. The used bones will be i (base finger), i+1 (mid finger) and i+2 (tip finger).             thumb:  boneMap[ handName + "HandThumb" ],             index:  boneMap[ handName + "HandIndex" ],            middle: boneMap[ handName + "HandMiddle" ],             ring:   boneMap[ handName + "HandRing" ],             pinky:  boneMap[ handName + "HandPinky" ]         };        this.thumbTwistAxis = (new THREE.Vector3()).copy(this.skeleton.bones[ this.idxs.thumb + 1 ].position).normalize();        this.defG = [ [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0] ];        this.srcG = [ [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0] ];        this.trgG = [ [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0] ];        this.curG = [ [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0] ];                this.time = 0; // current time of transition        this.start = 0;        this.attackPeak = 0;        this.relax = 0;         this.end = 0;        this.transition = false;                this.reset();    }        reset() {        for( let i = 0; i < this.defG.length; ++i ){            this.defG[i].fill(0);            this.srcG[i].fill(0);            this.trgG[i].fill(0);            this.curG[i].fill(0);        }        this.time = 1; this.start = 0; this.attackPeak = 0; this.relax = 0; this.end = 0;        this.update( 1 ); // force position reset    }           // must always update bones. (this.transition would be useless)    update( dt ) {                if ( this.transition ) {            this.time += dt;            // wait in same pose            // if ( this.time <= this.start ){ }                          // transition from start to peak            if ( this.time > this.start && this.time <= this.attackPeak ){                let t = ( this.time - this.start ) / ( this.attackPeak - this.start );                if ( t > 1){ t = 1; }                t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;                                for( let i = 0; i < this.curG.length; ++i ){                    let curFinger = this.curG[i];                    let srcFinger = this.srcG[i];                    let trgFinger = this.trgG[i];                    for( let j = 0; j < curFinger.length; ++j ){                        curFinger[j] = srcFinger[j] * (1-t) + trgFinger[j] * t;                    }                }            }                // wait in peak            else if ( this.time > this.attackPeak && this.time < this.relax ){                 for( let i = 0; i < this.curG.length; ++i ){                    let curFinger = this.curG[i];                    let trgFinger = this.trgG[i];                    for( let j = 0; j < curFinger.length; ++j ){                        curFinger[j] = trgFinger[j];                    }                }            }            // transition from peak to default position            else if ( this.time >= this.relax ){                let t = ( this.time - this.relax ) / ( this.end - this.relax );                if ( t > 1){ t = 1; }                t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;                    for( let i = 0; i < this.curG.length; ++i ){                    let curFinger = this.curG[i];                    let defFinger = this.defG[i];                    let trgFinger = this.trgG[i];                    for( let j = 0; j < curFinger.length; ++j ){                        curFinger[j] = trgFinger[j] * (1-t) + defFinger[j] * t;                    }                }                if ( this.time >= this.end ){ this.transition = false; }            }                    }        // TODO                let bones = this.skeleton.bones;        let bendAxes = (this.mirror) ? avatarHandAxes.L.bends : avatarHandAxes.R.bends;            let splayAxes = (this.mirror) ? avatarHandAxes.L.splays : avatarHandAxes.R.splays;         let c = this.curG;                   // all finger bends        bones[ this.idxs.thumb      ].quaternion.setFromAxisAngle(  bendAxes[0],  ((1-c[0][1])*1.5-0.5) * (-Math.PI*0.2) ); // these maths because of weird thumb position in mesh         bones[ this.idxs.thumb + 1  ].quaternion.setFromAxisAngle(  bendAxes[1],  c[0][2] * Math.PI*0.4 );        bones[ this.idxs.thumb + 2  ].quaternion.setFromAxisAngle(  bendAxes[2],  c[0][3] * Math.PI*0.4 );        bones[ this.idxs.index      ].quaternion.setFromAxisAngle(  bendAxes[3],  c[1][1] * Math.PI*0.5 );        bones[ this.idxs.index + 1  ].quaternion.setFromAxisAngle(  bendAxes[4],  c[1][2] * Math.PI*0.6 );        bones[ this.idxs.index + 2  ].quaternion.setFromAxisAngle(  bendAxes[5],  c[1][3] * Math.PI*0.5 );        bones[ this.idxs.middle     ].quaternion.setFromAxisAngle(  bendAxes[6],  c[2][1] * Math.PI*0.5 );        bones[ this.idxs.middle + 1 ].quaternion.setFromAxisAngle(  bendAxes[7],  c[2][2] * Math.PI*0.6 );        bones[ this.idxs.middle + 2 ].quaternion.setFromAxisAngle(  bendAxes[8],  c[2][3] * Math.PI*0.5 );        bones[ this.idxs.ring       ].quaternion.setFromAxisAngle(  bendAxes[9],  c[3][1] * Math.PI*0.5 );        bones[ this.idxs.ring + 1   ].quaternion.setFromAxisAngle(  bendAxes[10], c[3][2] * Math.PI*0.6 * 0.9 ); // 0.9 because of eva model        bones[ this.idxs.ring + 2   ].quaternion.setFromAxisAngle(  bendAxes[11], c[3][3] * Math.PI*0.5 );        bones[ this.idxs.pinky      ].quaternion.setFromAxisAngle(  bendAxes[12], c[4][1] * Math.PI*0.5 );        bones[ this.idxs.pinky + 1  ].quaternion.setFromAxisAngle(  bendAxes[13], c[4][2] * Math.PI*0.6 );        bones[ this.idxs.pinky + 2  ].quaternion.setFromAxisAngle(  bendAxes[14], c[4][3] * Math.PI*0.5 );        // thumb splay is weird        bones[ this.idxs.thumb ].quaternion.multiply( _tempHandQuat.setFromAxisAngle(  splayAxes[0], c[0][0] * Math.PI*0.15 ) );        bones[ this.idxs.thumb ].quaternion.multiply( _tempHandQuat.setFromAxisAngle(  this.thumbTwistAxis, (this.mirror?1:-1) * Math.max( 0, c[0][0] ) * Math.PI*0.3 ) );        // other fingers splay        bones[ this.idxs.index  ].quaternion.multiply( _tempHandQuat.setFromAxisAngle(  splayAxes[1], this._computeSplayAngle( c[1] ) ) );        bones[ this.idxs.middle ].quaternion.multiply( _tempHandQuat.setFromAxisAngle(  splayAxes[2], this._computeSplayAngle( c[2] ) ) );        bones[ this.idxs.ring   ].quaternion.multiply( _tempHandQuat.setFromAxisAngle(  splayAxes[3], -1 * this._computeSplayAngle( c[3] ) ) );        bones[ this.idxs.pinky  ].quaternion.multiply( _tempHandQuat.setFromAxisAngle(  splayAxes[4], -1 * this._computeSplayAngle( c[4] ) - this._computeSplayAngle( c[3] ) ) );            }    _computeSplayAngle( fingerInfo ){        return fingerInfo[0] * ( 1 - Math.abs( fingerInfo[1] ) ) * 20*Math.PI/180;    }        _stringToMainBend( mainbend, handArray, selectedFingers ){                // thumb combinations + mainbend. Do not need to change splay        // bent  "bend1":"800" fingers:"900"        // round "bend1":"434" fingers:"569"        // hooked "bend1":"818","bend2":"966"         // dblhooked and dblbent do not exist in hamnosys. Assume hooked                let b = handBendings[ mainbend ];        if ( !b ){ return; }        // thumb combinations        if ( selectedFingers[0] == 2 ){            let bt = b[2].t;            handArray[0][1] = bt[0];             handArray[0][2] = bt[1];             handArray[0][3] = bt[2];         }        // rest of fingers        for( let i = 1; i < 5; ++i ){            if ( selectedFingers[i] == 1 ){                 let f = b[1];                handArray[i][1] = f[0];                 handArray[i][2] = f[1];                 handArray[i][3] = f[2];             }            if ( selectedFingers[i] == 2 ){                 let bf = b[2].f;                handArray[i][1] = bf[0];                 handArray[i][2] = bf[1];                 handArray[i][3] = bf[2];             }        }    }    _stringToFingerBend( str, outFinger, selectMode = 0 ){        if ( !str ){ return; }        let b = handBendings[ str ];        if ( !b ){             if ( typeof( str ) == "string" ){                // strings of three int values 0-9                for( let i = 0; (i < 3) && (i < str.length); ++i ){                    let val = parseInt( str[i] );                    if ( isNaN(val) ){ continue; }                    outFinger[1+i] = val/9;                }            }            return;        }        if ( selectMode == 1 ){             let f = b[1];            outFinger[1] = f[0];             outFinger[2] = f[1];             outFinger[3] = f[2];         }        if ( selectMode == 2 ){             let bf = b[2].f;            outFinger[1] = bf[0];             outFinger[2] = bf[1];             outFinger[3] = bf[2];         }    }    _stringToSplay( str, outFinger ){        let val = str;        // strings int values 0-8        if ( typeof val == "string" ){             val = parseFloat( val );        }         if ( isNaN(val) ){ return; }        outFinger[0] = val;            }    // to avoid having duplicated code for main and second attributes. Fills outHand. Returns 0 on success, >0 otherwise    _newGestureHandComposer( bml, outHand, isSecond ){        let g = handShapes[ isSecond ? bml.secondHandshape : bml.handshape ];        if ( !g ){             console.warn( "Gesture: HandShape incorrect handshape \"" + (isSecond ? bml.secondHandshape : bml.handshape) + "\"" );            return 1;        }                    // copy selected shape into buffers        for( let i = 0; i < outHand.length; ++i ){            let finger = outHand[i];            let source = g.shape[i];            for( let j = 0; j < finger.length; ++j ){ finger[j] = source[j]; }        }                // apply mainbends if any        this._stringToMainBend( isSecond ? bml.secondMainBend : bml.mainBend, outHand, g.selected );        // modify with thumbshape        let thumbGest = thumbShapes[ isSecond ? bml.secondThumbshape : bml.thumbshape ];        if ( thumbGest ){            for( let i = 0; i < thumbGest.length; ++i ){ outHand[0][i] = thumbGest[i]; }                }        // thumb combination opening. Applicable to cee and pinch (select mode 2). 1=keep original, 0=open fingers        let thumbCombinationOpening = parseFloat( isSecond ? bml.secondtco : bml.tco );        thumbCombinationOpening = isNaN( thumbCombinationOpening ) ? 0 : Math.max(0, Math.min(1, thumbCombinationOpening ) );        for( let i = 0; i < outHand.length; ++i ){            let finger = outHand[i];            let fingerOpeningFactor = ( g.selected[i] == 2 ) ? thumbCombinationOpening : 0;            fingerOpeningFactor *= ( i == 0 ) ? 0.25 : 1;            for( let j = 0; j < finger.length; ++j ){ finger[j] = finger[j] * ( 1 - fingerOpeningFactor ); }        }        return 0;    }    /**      * bml info     * start, attackPeak, relax, end     * handshape: string from the handshape tables     * f1, f2, f3, f4, f5: string from the handshape tables. Overrides handshape and thumbshape for that specific finger. 1=thumb, 5=pinky     * thumbshape: (optional) string from thumbshape table.     */    newGestureBML( bml ){                      if ( this._newGestureHandComposer( bml, this.trgG, false ) ){ return; }// something went wrong        if ( bml.secondHandshape ){             this._newGestureHandComposer( bml, this.srcG, true ); // use this.srcG as temporal buffer            for( let i = 0; i < this.trgG.length; ++i ){                for( let j = 0; j < this.trgG.length; ++j ){                    this.trgG[i][j] = this.trgG[i][j] * 0.5 +  this.srcG[i][j] * 0.5;                }            }        }        // specific bendings        this._stringToFingerBend( bml.bend1, this.trgG[0], 1 ); // thumb        this._stringToFingerBend( bml.bend2, this.trgG[1], 1 );        this._stringToFingerBend( bml.bend3, this.trgG[2], 1 );        this._stringToFingerBend( bml.bend4, this.trgG[3], 1 );        this._stringToFingerBend( bml.bend5, this.trgG[4], 1 );        // check if any splay attributes is present. ( function already checks if passed argument is valid )                   this._stringToSplay( bml.splay1, this.trgG[0] ); // thumb        this._stringToSplay( bml.splay2 ? bml.splay2 : bml.mainSplay, this.trgG[1] );        this._stringToSplay( bml.splay3 ? bml.splay3 : bml.mainSplay, this.trgG[2] );        this._stringToSplay( bml.splay4 ? bml.splay4 : bml.mainSplay, this.trgG[3] );        this._stringToSplay( bml.splay5 ? bml.splay5 : bml.mainSplay, this.trgG[4] );        // set default pose if necessary        if ( bml.shift ){            for( let i = 0; i < this.trgG.length; ++i ){                let trgFinger = this.trgG[i];                let defFinger = this.defG[i];                for( let j = 0; j < trgFinger.length; ++j ){                    defFinger[j] = trgFinger[j];                }            }        }        // copy current state into src        for( let i = 0; i < this.trgG.length; ++i ){            let srcFinger = this.srcG[i];            let curFinger = this.curG[i];            for( let j = 0; j < curFinger.length; ++j ){                srcFinger[j] = curFinger[j];            }        }        // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;                     this.transition = true;    }}
// Description of sigml points supported. keys: our proposal (what the realizer uses). Values: list of tags of sigml that are mapped to that key// headtop : headtop,// forehead : head, forehead,// eyeL : eyebrows, eyes, uppereyelid, lowereyelid,// eyeR : eyebrows, eyes, uppereyelid, lowereyelid,// nose : nose,// upperlip : nostrils, upperlip,// mouth: lips, lowerlip, tongue, teeth, upperteeth, lowerteeth,// chin : chin, underchin,// earL : ear, earlobe,// earR : ear, earlobe,// cheekL : cheek,// cheekR : cheek,// neck : neck,// shoulderL : shoulders, shouldertop,// shoulderR : shoulders, shouldertop,// chest : chest,// stomach : stomach,// belowstomach : belowstomach,// arm quaternions from right arm perspective// [ ShoulderBack, Shoulder, Elbow ]let nearPoses = {    neutral:        [ new THREE.Quaternion(-0.0030244,-0.6014008,0.0175197,0.7987496), new THREE.Quaternion(0.5977453,0.1557497,-0.0462050,0.7850526), new THREE.Quaternion(0.2523842,0.2125053,0.0112892,0.9439365)  ],    headtop:        [ new THREE.Quaternion(-0.0506604,-0.7341385,-0.0660531,0.6738776), new THREE.Quaternion(-0.4668017,0.0198618,-0.0204699,0.8839019), new THREE.Quaternion(-0.6623683,0.1071393,-0.0464818,0.7400194)  ],    forehead:       [ new THREE.Quaternion(0.0052382,-0.7376279,0.0058476,0.6751617), new THREE.Quaternion(-0.0995180,0.7498349,-0.0055130,0.6540743), new THREE.Quaternion(-0.6971409,0.3354671,-0.0556369,0.6311582)  ],    eyeL:           [ new THREE.Quaternion(0.1273960,-0.7585008,0.1566673,0.6195983), new THREE.Quaternion(0.0285814,0.8482021,-0.0000513,0.5289008), new THREE.Quaternion(-0.4557415,0.5937748,-0.0472286,0.6614382)  ],    eyeR:           [ new THREE.Quaternion(0.1152192,-0.7544016,0.1422677,0.6303669), new THREE.Quaternion(0.0714903,0.8325108,0.0018608,0.5493736), new THREE.Quaternion(-0.5646459,0.5390549,-0.0528718,0.6227353)  ],    nose:           [ new THREE.Quaternion(-0.0252475,-0.7199582,-0.0304132,0.6928908), new THREE.Quaternion(0.0454818,0.7106191,0.0009248,0.7021046), new THREE.Quaternion(-0.6405263,0.5539174,-0.0584294,0.5286657)  ],    upperlip:       [ new THREE.Quaternion(-0.0288777,-0.7174093,-0.0346774,0.6951887), new THREE.Quaternion(0.0694745,0.6986833,0.0019989,0.7120469), new THREE.Quaternion(-0.5996578,0.6148312,-0.0575356,0.5090016)  ],    mouth:          [ new THREE.Quaternion(-0.0039781,-0.7422616,-0.0068752,0.6700630), new THREE.Quaternion(0.1569718,0.7319968,0.0057865,0.6629531), new THREE.Quaternion(-0.5367775,0.6554966,-0.0545482,0.5284112)  ],    chin:           [ new THREE.Quaternion(-0.0144784,-0.7336383,-0.0188906,0.6791231), new THREE.Quaternion(0.2120324,0.6909716,0.0082736,0.6910368), new THREE.Quaternion(-0.4265878,0.7764973,-0.0508725,0.4609626)  ],    cheekL:         [ new THREE.Quaternion(0.0352934,-0.7555276,0.0411269,0.6528713), new THREE.Quaternion(0.0514777,0.8204809,0.0010022,0.5693505), new THREE.Quaternion(-0.4342420,0.7208578,-0.0496679,0.5378949)  ],    cheekR:         [ new THREE.Quaternion(0.0230982,-0.7083715,0.0339334,0.7046451), new THREE.Quaternion(0.1192426,0.7429874,0.0041107,0.6585848), new THREE.Quaternion(-0.7864518,0.4759690,-0.0659315,0.3880720)  ],    earL:           [ new THREE.Quaternion(0.1029711,-0.6166821,0.1499909,0.7659000), new THREE.Quaternion(0.0893024,0.8568030,0.0026013,0.5078452), new THREE.Quaternion(-0.3381405,0.7009594,-0.0426242,0.6264982)  ],    earR:           [ new THREE.Quaternion(0.1681397,-0.5996382,0.2337173,0.7466855), new THREE.Quaternion(-0.1995244,0.7336113,-0.0098819,0.6495434), new THREE.Quaternion(-0.7972906,0.4242612,-0.0650900,0.4243739)  ],    neck:           [ new THREE.Quaternion(-0.0311668,-0.6967750,-0.0340783,0.7158014), new THREE.Quaternion(0.4273569,0.5905589,0.0178945,0.6843142), new THREE.Quaternion(-0.2417393,0.8818185,-0.0417702,0.4027573)  ],    chest:          [ new THREE.Quaternion(-0.0107485,-0.6729800,-0.0036564,0.7395734), new THREE.Quaternion(0.6108346,0.2714558,0.0264699,0.7432981), new THREE.Quaternion(0.2821601,0.8551173,-0.0061830,0.4348812)  ],    stomach:        [ new THREE.Quaternion(-0.0125816,-0.6608236,-0.0040435,0.7504248), new THREE.Quaternion(0.5685093,0.1448031,0.0248173,0.8094524), new THREE.Quaternion(0.5358218,0.5919117,0.0185811,0.6018223)  ],    belowstomach:   [ new THREE.Quaternion(-0.0134201,-0.6603696,-0.0050532,0.7508037), new THREE.Quaternion(0.5879901,0.1971521,0.0255878,0.7840560), new THREE.Quaternion(0.4416799,0.2915858,0.0214299,0.8481964)  ],    shoulderL:      [ new THREE.Quaternion(0.0466722,-0.5776748,0.0846167,0.8105266), new THREE.Quaternion(0.4878578,0.5500982,0.0206168,0.6774670), new THREE.Quaternion(0.2735958,0.8199461,-0.0056520,0.5027938)  ],    shoulderR:      [ new THREE.Quaternion(-0.0091726,-0.7450993,-0.0141048,0.6667412), new THREE.Quaternion(0.5866297,0.3048243,0.0253537,0.7498699), new THREE.Quaternion(-0.3295025,0.9072888,-0.0484754,0.2567200)  ],    }    // 1 = right, 5 = left. Different numbering than "signing space" of Irene's thesis. This is better for symmetry and others    nearPoses.loctop1 = nearPoses.shoulderR;           nearPoses.loctop2 = nearPoses.shoulderR;           nearPoses.loctop3 = nearPoses.shoulderR;            nearPoses.loctop4 = nearPoses.shoulderR;           nearPoses.loctop5 = nearPoses.shoulderR;            nearPoses.locmid1 = nearPoses.shoulderR;           nearPoses.locmid2 = nearPoses.shoulderR;           nearPoses.locmid3 = nearPoses.shoulderR;            nearPoses.locmid4 = nearPoses.shoulderR;           nearPoses.locmid5 = nearPoses.shoulderR;            nearPoses.locbot1 = nearPoses.shoulderR;           nearPoses.locbot2 = nearPoses.shoulderR;           nearPoses.locbot3 = nearPoses.shoulderR;            nearPoses.locbot4 = nearPoses.shoulderR;           nearPoses.locbot5 = nearPoses.shoulderR;                    // positions to be used by iklet farPoses = {    neutral:      new THREE.Vector3( 0,1.8,1),        headtop:      new THREE.Vector3( 0,2.5,0.1),            forehead:     new THREE.Vector3( 0.0,1.5,0.5 ),     eyeL:         new THREE.Vector3( 0.0,1.5,0.5 ),      eyeR:         new THREE.Vector3( 0.0,1.5,0.5 ),      nose:         new THREE.Vector3( 0.0,1.5,0.5 ),      upperlip:     new THREE.Vector3( 0.0,1.5,0.5 ),      mouth:        new THREE.Vector3( 0.0,1.5,0.5 ),       chin:         new THREE.Vector3( 0.0,1.5,0.5 ),     cheekR:       new THREE.Vector3( 0.0,1.5,0.5 ),      cheekL:       new THREE.Vector3( 0.0,1.5,0.5 ),       earL:         new THREE.Vector3( 0.0,1.5,0.5 ),      earR:         new THREE.Vector3( 0.0,1.5,0.5 ),       neck:         new THREE.Vector3( 0.0,1.40,0.5 ),      chest:        new THREE.Vector3( 0.0,1.30,0.5 ),      stomach:      new THREE.Vector3( 0.0,1.15,0.5 ),    belowstomach: new THREE.Vector3( 0.0,1.00,0.5 ),     shoulderL:    new THREE.Vector3( 0.0,1.30,0.5 ),     shoulderR:    new THREE.Vector3( 0.0,1.30,0.5 ),     // 1 = right, 5 = left. Different numbering than "signing space" of Irene's thesis. This is better for symmetry and others    loctop1:      new THREE.Vector3(-0.59,2.00,0.23 ),       loctop2:      new THREE.Vector3(-0.29,2.00,0.39 ),       loctop3:      new THREE.Vector3( 0.00,2.00,0.46 ),       loctop4:      new THREE.Vector3( 0.29,2.00,0.39 ),       loctop5:      new THREE.Vector3( 0.59,2.00,0.23 ),       locmid1:      new THREE.Vector3(-0.59,1.30,0.23 ),    locmid2:      new THREE.Vector3(-0.29,1.30,0.39 ),    locmid3:      new THREE.Vector3( 0.00,1.30,0.46 ),    locmid4:      new THREE.Vector3( 0.29,1.30,0.39 ),    locmid5:      new THREE.Vector3( 0.59,1.30,0.23 ),                    locbot1:      new THREE.Vector3( -0.59,0.74,0.23 ),    locbot2:      new THREE.Vector3( -0.29,0.74,0.39 ),    locbot3:      new THREE.Vector3(  0.00,0.74,0.46 ),    locbot4:      new THREE.Vector3(  0.29,0.74,0.31 ),    locbot5:      new THREE.Vector3(  0.59,0.74,0.18 ),}let sides = {    'u'     : (new THREE.Vector3(  0,   1,   0 )).normalize(),       'ul'    : (new THREE.Vector3(  1,   1,   0 )).normalize(),       'l'     : (new THREE.Vector3(  1,   0,   0 )).normalize(),       'dl'    : (new THREE.Vector3(  1,  -1,   0 )).normalize(),       'd'     : (new THREE.Vector3(  0,  -1,   0 )).normalize(),       'dr'    : (new THREE.Vector3( -1,  -1,   0 )).normalize(),      'r'     : (new THREE.Vector3( -1,   0,   0 )).normalize(),      'ur'    : (new THREE.Vector3( -1,   1,   0 )).normalize(),      "uo"    : (new THREE.Vector3(  0,   1,   1 )).normalize(),    "uol"   : (new THREE.Vector3(  1,   1,   1 )).normalize(),    "ol"    : (new THREE.Vector3(  1,   0,   1 )).normalize(),    "dol"   : (new THREE.Vector3(  1,  -1,   1 )).normalize(),    "do"    : (new THREE.Vector3(  0,  -1,   1 )).normalize(),    "dor"   : (new THREE.Vector3( -1,  -1,   1 )).normalize(),    "or"    : (new THREE.Vector3( -1,   0,   1 )).normalize(),    "uor"   : (new THREE.Vector3( -1,   1,   1 )).normalize(),    "o"     : (new THREE.Vector3(  0,   0,   1 )).normalize(),        "ui"    : (new THREE.Vector3(  0,   1,  -1 )).normalize(),    "uil"   : (new THREE.Vector3(  1,   1,  -1 )).normalize(),    "il"    : (new THREE.Vector3(  1,   0,  -1 )).normalize(),    "dil"   : (new THREE.Vector3(  1,  -1,  -1 )).normalize(),    "di"    : (new THREE.Vector3(  0,  -1,  -1 )).normalize(),    "dir"   : (new THREE.Vector3( -1,  -1,  -1 )).normalize(),    "ir"    : (new THREE.Vector3( -1,   0,  -1 )).normalize(),    "uir"   : (new THREE.Vector3( -1,   1,  -1 )).normalize(),    "i"     : (new THREE.Vector3(  0,   0,  -1 )).normalize(),}class LocationArmIK {    constructor( boneMap, skeleton, ikSolver, isLeftHand = false ) {        this.skeleton = skeleton;        this.ikSolver = ikSolver;        this.chainInfo = null;        this.mirror = !!isLeftHand;        this.idx = ( isLeftHand ) ? boneMap[ "LShoulder" ] : boneMap[ "RShoulder" ]; // shoulder (back) index         this.chainInfo = ( isLeftHand ) ? this.ikSolver.getChain( "LeftArm" ) : this.ikSolver.getChain( "RightArm" );        // three bones: shoulder (back), actual shoulder, elbow        this.defG = [new THREE.Quaternion(), new THREE.Quaternion(), new THREE.Quaternion()]; // default gesture        this.srcG = [new THREE.Quaternion(), new THREE.Quaternion(), new THREE.Quaternion()]; // source gesture        this.trgG = [new THREE.Quaternion(), new THREE.Quaternion(), new THREE.Quaternion()]; // target gesture        this.curG = [new THREE.Quaternion(), new THREE.Quaternion(), new THREE.Quaternion()]; // target gesture        this.time = 0; // current time of transition        this.start = 0;         this.attackPeak = 0;        this.relax = 0;        this.end = 0;                this.transition = false;        // set default poses        this.reset();    }    reset(){        this.transition = false;        this.curG[0].copy( nearPoses.neutral[0] );        this.curG[1].copy( nearPoses.neutral[1] );        this.curG[2].copy( nearPoses.neutral[2] );        this.defG[0].copy( nearPoses.neutral[0] );        this.defG[1].copy( nearPoses.neutral[1] );        this.defG[2].copy( nearPoses.neutral[2] );    }    update( dt ){        // nothing to do        if ( !this.transition ){ return; }                 this.time += dt;                // wait in same pose        if ( this.time < this.start ){ return; }        if ( this.time > this.attackPeak && this.time < this.relax ){             for( let i = 0; i < 3 ; ++i ){                this.curG[i].copy( this.trgG[i] );            }            return;         }                // move to default pose and end        if ( this.time > this.end ){             for( let i = 0; i < 3 ; ++i ){                this.curG[i].copy( this.defG[i] );            }            this.transition = false; // flag as "nothing to do"            return;         }        if ( this.time <= this.attackPeak ){            let t = ( this.time - this.start ) / ( this.attackPeak - this.start );            if ( t > 1){ t = 1; }            t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;            // shouldar (back), actual shoulder, elbow            for( let i = 0; i < 3 ; ++i ){                this.curG[i].slerpQuaternions( this.srcG[i], this.trgG[i], t ); // expensive but finds correct path                //nlerpQuats( this.curG[i], this.srcG[i], this.trgG[i], t ); // cheaper but does not find correct path            }                 return;        }        if ( this.time >= this.relax ){            let t = ( this.time - this.relax ) / ( this.end - this.relax );            if ( t > 1){ t = 1; }            t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;            // shouldar (back), actual shoulder, elbow            for( let i = 0; i < 3 ; ++i ){                this.curG[i].slerpQuaternions( this.trgG[i], this.defG[i], t ); // expensive but finds correct path                //nlerpQuats( this.curG[i], this.trgG[i], this.defG[i], t ); // cheaper  but does not find correct path            }             }    }    /**     * bml info     * start, attackPeak, relax, end     * locationArm: string from nearPoses     * distance: (optional) [0,1] how far from the body to locate the hand. 0 = close, 1 = arm extended     * side: (optional) string from sides table. Location will offset into that direction     * sideDistance: (optional) how far to move the indicate side. Metres     */    newGestureBML( bml, symmetry = 0x00, lastFrameQuaternions = null ) {        let tempV = new THREE.Vector3(0,0,0);        // distance: touch vs far        let distance = isNaN( bml.distance ) ? 0 : bml.distance;        let location = bml.locationArm;        // for mirror - with left arm, to point right shoulder the "shoulderL" is needed, and then quaternions must be mirrored        // for symmetry - the left and right must be swapped        // not only quaternions are mirrored. The left/right actions need to be swapped. All actions in table are from right arm's perspective        if ( (this.mirror ^ ( symmetry & 0x01 ) ) && location ){             if ( location[location.length-1] == "L" ){                location = location.slice(0, location.length-1) + "R";            }             else if( location[location.length-1] == "R" ){                location = location.slice(0, location.length-1) + "L";            }         }                let near = nearPoses[ location ];        let far = farPoses[ location ];        if ( !near || !far ){            console.warn( "Gesture: Location Arm no location found with name \"" + location + "\"" );            return;        }        // Set target and source poses AND prepare skeleton for ik        for ( let i = 0; i < near.length; ++i ){            // source: Copy current arm state            this.srcG[i].copy( lastFrameQuaternions ? lastFrameQuaternions[i] : this.curG[i] );            // target (reference)            this.trgG[i].copy( near[i] );            // mirror target quaternion. (left arm cannot use right arms Quaternions as they are)            if ( this.mirror ){                 mirrorQuatSelf( this.trgG[i] );            }                        // IK - copy nearTarget into bone quaternions            this.skeleton.bones[ this.idx + i ].quaternion.copy( this.trgG[i] );         }        // set ikTarget as lerp( nearPoint, farPoint, distance ) + side        let pos = tempV;        this.skeleton.bones[ this.chainInfo.chain[0] ].getWorldPosition( pos )        this.chainInfo.target.position.x = pos.x * (1-distance) + far.x * distance;        this.chainInfo.target.position.y = pos.y * (1-distance) + far.y * distance;        this.chainInfo.target.position.z = pos.z * (1-distance) + far.z * distance;        // same as in location        let side = bml.side;        if ( side && symmetry ){ side = directionStringSymmetry( side, symmetry ); }        side = sides[ side ];        if ( side ){            let secondSide = bml.secondSide;            if ( secondSide && symmetry ){ secondSide = directionStringSymmetry( secondSide, symmetry ); }            secondSide = sides[ secondSide ];            if( !secondSide ){ secondSide = side; }            let finalSide = tempV;            finalSide.lerpVectors( side, secondSide, 0.5 );            finalSide.normalize();             if( finalSide.lengthSq() < 0.0001 ){ finalSide.copy( side ); }            let sideDist = isNaN( bml.sideDistance ) ? 0 : bml.sideDistance;            this.chainInfo.target.position.x += finalSide.x * sideDist;            this.chainInfo.target.position.y += finalSide.y * sideDist;            this.chainInfo.target.position.z += finalSide.z * sideDist;        }        // Actual IK        this.chainInfo.enabler = true;        this.ikSolver.update();        this.chainInfo.enabler = false;        // Save IK results        for ( let i = 0; i < near.length; ++i ){            // copy results into target            this.trgG[i].copy( this.skeleton.bones[ this.idx + i ].quaternion );                        // copy src (current quaternions) into bone quaternions            this.skeleton.bones[ this.idx + i ].quaternion.copy( this.srcG[i] );                                    // copy src into curG (not really needed, just in case)            this.curG[i].copy( this.srcG[i] );             // change arm's default pose if necesary            if ( bml.shift ){                this.defG[i].copy( this.trgG[i] );            }        }        // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;        this.transition = true;    }   }let nearArmPosesTable = nearPoses;
let _tempVec3_0 = new THREE.Vector3(0,0,0);let _tempQuat_0 = new THREE.Quaternion(0,0,0,1);let motionDirectionTable = {    'u'     : (new THREE.Vector3(  0,   1,   0 )).normalize(),       'ul'    : (new THREE.Vector3(  1,   1,   0 )).normalize(),       'l'     : (new THREE.Vector3(  1,   0,   0 )).normalize(),       'dl'    : (new THREE.Vector3(  1,  -1,   0 )).normalize(),       'd'     : (new THREE.Vector3(  0,  -1,   0 )).normalize(),       'dr'    : (new THREE.Vector3( -1,  -1,   0 )).normalize(),      'r'     : (new THREE.Vector3( -1,   0,   0 )).normalize(),      'ur'    : (new THREE.Vector3( -1,   1,   0 )).normalize(),      "uo"    : (new THREE.Vector3(  0,   1,   1 )).normalize(),    "uol"   : (new THREE.Vector3(  1,   1,   1 )).normalize(),    "ol"    : (new THREE.Vector3(  1,   0,   1 )).normalize(),    "dol"   : (new THREE.Vector3(  1,  -1,   1 )).normalize(),    "do"    : (new THREE.Vector3(  0,  -1,   1 )).normalize(),    "dor"   : (new THREE.Vector3( -1,  -1,   1 )).normalize(),    "or"    : (new THREE.Vector3( -1,   0,   1 )).normalize(),    "uor"   : (new THREE.Vector3( -1,   1,   1 )).normalize(),    "o"     : (new THREE.Vector3(  0,   0,   1 )).normalize(),        "ui"    : (new THREE.Vector3(  0,   1,  -1 )).normalize(),    "uil"   : (new THREE.Vector3(  1,   1,  -1 )).normalize(),    "il"    : (new THREE.Vector3(  1,   0,  -1 )).normalize(),    "dil"   : (new THREE.Vector3(  1,  -1,  -1 )).normalize(),    "di"    : (new THREE.Vector3(  0,  -1,  -1 )).normalize(),    "dir"   : (new THREE.Vector3( -1,  -1,  -1 )).normalize(),    "ir"    : (new THREE.Vector3( -1,   0,  -1 )).normalize(),    "uir"   : (new THREE.Vector3( -1,   1,  -1 )).normalize(),    "i"     : (new THREE.Vector3(  0,   0,  -1 )).normalize(),}// in x,y plane -> angle with respect to +y axislet motionCurveTable = {    'u'     : 0 * Math.PI / 180,       'ul'    : 315 * Math.PI / 180,       'l'     : 270 * Math.PI / 180,       'dl'    : 225 * Math.PI / 180,       'd'     : 180 * Math.PI / 180,       'dr'    : 135 * Math.PI / 180,      'r'     : 90 * Math.PI / 180,      'ur'    : 45 * Math.PI / 180,  }class DirectedMotion {    constructor(){        this.finalOffset = new THREE.Vector3(0,0,0);                this.bezier = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ]        this.distance = 0.05; // metres        this.steepness = 0.5; // [0,1] curve steepness        this.zigzagDir = new THREE.Vector3(0,0,1);        this.zigzagSize = 0.01; // metres. Complete amplitude. Motion will move half to dir and half to -dir        this.zigzagSpeed = 2; // loops per second        this.transition = false;        this.time = 0;        this.start = 0;        this.attackPeak = 0;        this.relax = 0;        this.end = 0;    }    reset(){        this.transition = false;        this.finalOffset.set(0,0,0);    }    update( dt ){        if ( !this.transition ){ return; }                this.time += dt;        if ( this.time < this.start ){ return this.finalOffset; }        else if ( this.time < this.attackPeak ){            let t = ( this.time - this.start ) / ( this.attackPeak - this.start );            // t = Math.sin( Math.PI * t - Math.PI * 0.5 ) * 0.5 + 0.5; // commented because of sigml purposes            cubicBezierVec3( this.bezier[0], this.bezier[1], this.bezier[2], this.bezier[3], this.finalOffset, t );            let zigzagAttenuation = Math.min( ( this.attackPeak - this.time ) / 0.5, Math.min( 1, ( this.time - this.start ) / 0.5 ) );  // min( outro, full, intro ). 0.5 seconds of intro and 0.5 of outro if possible            let zigzagt = Math.sin( Math.PI * 2 * this.zigzagSpeed * ( this.time - this.start ) ) * this.zigzagSize * 0.5 * zigzagAttenuation;            this.finalOffset.x = this.finalOffset.x + this.zigzagDir.x * zigzagt;            this.finalOffset.y = this.finalOffset.y + this.zigzagDir.y * zigzagt;            this.finalOffset.z = this.finalOffset.z + this.zigzagDir.z * zigzagt;        }        else if ( this.time < this.relax ){             this.finalOffset.copy( this.bezier[3] );        }        else if ( this.time < this.end ){ // lerp to origin (0,0,0)             let t = ( this.time - this.relax ) / ( this.end - this.relax );            // t = Math.sin( Math.PI * t - Math.PI * 0.5 ) * 0.5 + 0.5; // commented because of sigml purposes            this.finalOffset.copy( this.bezier[3] );            this.finalOffset.multiplyScalar( 1.0 - t );        }        else { this.transition = false; this.finalOffset.set(0,0,0); }        return this.finalOffset;    }    /**     * bml info     * start, attackPeak, relax, end     * direction: string from motionDirectionTable     * distance: (optional) size in metres of the displacement. Default 0.2 m (20 cm)     * curve: (optional) string from motionCurveTable. Default to none     * curveSteepness: (optional) number from [0,1] meaning the sharpness of the curve     * zigzag: (optional) string from motionDirectionTable     * zigzagSize: (optional) amplitude of zigzag (from highest to lowest point) in metres. Default 0.01 m (1 cm)     * zigzagSpeed: (optional) cycles per second. Default 2     */    newGestureBML( bml, symmetry ){        this.finalOffset.set(0,0,0);                  this.distance = isNaN( bml.distance ) ? 0.2 : bml.distance; // metres        this.steepness = isNaN( bml.curveSteepness ) ? 0.5 : Math.max( 0, Math.min( 1, bml.curveSteepness ) );                // fetch curve direction and adjust steepness if not present        let curveDir = bml.curve;        if ( curveDir && symmetry ){ curveDir = directionStringSymmetry( curveDir, symmetry ); }        curveDir = motionCurveTable[ curveDir ];        if ( isNaN( curveDir ) ){ this.steepness = 0; }        else{            //second curve direction            let secondCurveDir = bml.secondCurve;            if ( secondCurveDir && symmetry ){ secondCurveDir = directionStringSymmetry( secondCurveDir, symmetry ); }            secondCurveDir = motionCurveTable[ secondCurveDir ];            if ( isNaN( secondCurveDir ) ){ secondCurveDir = curveDir; }            else{                // find shortest path in circle                if ( ( curveDir - secondCurveDir ) < -Math.PI ){ secondCurveDir -= 2 * Math.PI; }                else if ( ( curveDir - secondCurveDir ) > Math.PI ){ secondCurveDir += 2 * Math.PI; }            }            curveDir = 0.5 * curveDir + 0.5 * secondCurveDir;        }        // set default direction (+z), default curve direction (+y) and ajust with size and curve steepness        this.bezier[0].set(0,0,0);        this.bezier[3].set(0,0,1).multiplyScalar( this.distance );        this.bezier[1].set(0,1,0.5).multiplyScalar( this.distance * this.steepness );        this.bezier[2].set(0,1,-0.5).multiplyScalar( this.distance * this.steepness ).add( this.bezier[3] );                        // rotate default curve direction (+y) to match user's one        if ( !isNaN( curveDir ) ){            _tempVec3_0.set(0,0,1);                    this.bezier[1].applyAxisAngle( _tempVec3_0, curveDir );            this.bezier[2].applyAxisAngle( _tempVec3_0, curveDir );        }        // fetch direction and secondDirection        let direction = bml.direction;        if ( direction && symmetry ){ direction = directionStringSymmetry( direction, symmetry ); }        direction = motionDirectionTable[ direction ];        if ( !direction ){             console.warn( "Gesture: Location Motion no direction found with name \"" + bml.direction + "\"" );            return;        }        let secondDirection = bml.secondDirection;        if ( secondDirection && symmetry ){ secondDirection = directionStringSymmetry( secondDirection, symmetry ); }        secondDirection = motionDirectionTable[ secondDirection ];        if ( !secondDirection ){ secondDirection = direction; }                let finalDir = _tempVec3_0;        finalDir.lerpVectors( direction, secondDirection, 0.5 );        finalDir.normalize();        if( finalDir.lengthSq < 0.0001 ){ finalDir.copy( direction ); }        // default looks at +z. If direction falls in -z, change default to -z to avoid accidental left-right, up-down mirror        if ( finalDir.z < 0 ){            this.bezier[0].z *= -1;            this.bezier[1].z *= -1;            this.bezier[2].z *= -1;            this.bezier[3].z *= -1;        }                // rotate default direction to match the user's one        let lookAtQuat = _tempQuat_0;        if ( Math.abs(finalDir.dot(this.bezier[3])) > 0.999 ){ lookAtQuat.set(0,0,0,1); }        else{             let angle = finalDir.angleTo( this.bezier[3] );            _tempVec3_0.crossVectors( this.bezier[3], finalDir );            _tempVec3_0.normalize();            lookAtQuat.setFromAxisAngle( _tempVec3_0, angle );        }        this.bezier[0].applyQuaternion( lookAtQuat );        this.bezier[1].applyQuaternion( lookAtQuat );        this.bezier[2].applyQuaternion( lookAtQuat );        this.bezier[3].applyQuaternion( lookAtQuat );        // zig-zag        let zigzag = motionDirectionTable[ bml.zigzag ];        if ( !zigzag ){            this.zigzagDir.set(0,0,0);            this.zigzagSize = 0.0; // metres            this.zigzagSpeed = 0; // rps        }else{            this.zigzagDir.copy( zigzag );            this.zigzagSize = isNaN( bml.zigzagSize ) ? 0.01 : bml.zigzagSize; // metres            this.zigzagSpeed = isNaN( bml.zigzagSpeed ) ? 2 : bml.zigzagSpeed; // rps        }        // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;         // flag to start         this.transition = true;    }}class CircularMotion {    constructor(){        this.finalOffset = new THREE.Vector3(0,0,0);        this.startPoint = new THREE.Vector3(0,0,0);        this.targetDeltaAngle = 0; // entry&outro easing + user specified.        this.axis = new THREE.Vector3(0,0,0);                this.zigzagDir = new THREE.Vector3(0,0,1);        this.zigzagSize = 0.01; // metres. Complete amplitude. Motion will move half to dir and half to -dir        this.zigzagSpeed = 2; // loops per second        this.transition = false;        this.time = 0;        this.start = 0;        this.end = 0;    }    reset(){        this.transition = false;        this.finalOffset.set(0,0,0);    }    update( dt ){        if ( !this.transition ){ return this.finalOffset; }                this.time += dt;        if ( this.time < this.start ){ return this.finalOffset; }        if ( this.time > this.attackPeak && this.time < this.relax ){ return this.finalOffset; }        if ( this.time >= this.relax && this.time <= this.end ){             this.finalOffset.copy( this.startPoint );            this.finalOffset.applyAxisAngle( this.axis, this.targetDeltaAngle );            this.finalOffset.multiplyScalar( ( this.end - this.time ) / ( this.end - this.relax ) );            return this.finalOffset;        }        if ( this.time >= this.end ){             this.transition = false;             this.finalOffset.set(0,0,0);             return this.finalOffset;        }        //if ( time > start && time < attackpeak ) start attackpeak        let t = ( this.time - this.start ) / ( this.attackPeak - this.start );        // t = Math.sin( Math.PI * t - Math.PI * 0.5 ) * 0.5 + 0.5;  // commented because of sigml purposes        t = ( t > 1 ) ? 1 : t;                // angle to rotate startPoint        let angle = this.targetDeltaAngle * t;                this.finalOffset.copy( this.startPoint );        this.finalOffset.applyAxisAngle( this.axis, angle )        // zigzag         if ( Math.abs(this.zigzagSize) > 0.0001 ){            let easing = Math.max( 0, Math.min( 1, Math.min( ( this.time - this.start ) / 0.5, ( this.attackPeak - this.time ) / 0.5 ) ) );            let zigzagt = Math.sin( Math.PI * 2 * this.zigzagSpeed * ( this.time - this.start ) ) * this.zigzagSize * 0.5 * easing;            this.finalOffset.x = this.finalOffset.x + this.zigzagDir.x * zigzagt;            this.finalOffset.y = this.finalOffset.y + this.zigzagDir.y * zigzagt;            this.finalOffset.z = this.finalOffset.z + this.zigzagDir.z * zigzagt;        }        this.finalOffset.sub( this.startPoint );        return this.finalOffset;    }    /**     * bml info     * start, attackPeak, relax, end     * direction: string from motionDirectionTable. Axis of rotation     * distance: (optional) radius in metres of the circle. Default 0.05 m (5 cm)     * startAngle: (optional) where in the circle to start. 0º indicates up. Indicated in degrees. Default to 0º. [-infinity, +infinity]     * endAngle: (optional) where in the circle to finish. 0º indicates up. Indicated in degrees. Default to 360º. [-infinity, +infinity]     * zigzag: (optional) string from motionDirectionTable     * zigzagSize: (optional) amplitude of zigzag (from highest to lowest point) in metres. Default 0.01 m (1 cm)     * zigzagSpeed: (optional) cycles per second. Default 2     */    newGestureBML( bml, symmetry ){        // debug        // this.color = Math.floor( Math.random() * 0xffffff );                        this.finalOffset.set(0,0,0);                // axis        let direction = bml.direction;        if ( direction && symmetry ){ direction = directionStringSymmetry( direction, symmetry ); }        direction = motionDirectionTable[ direction ];        if ( !direction ) { direction = motionDirectionTable['o']; }                let secondDirection = bml.secondDirection;        if ( secondDirection && symmetry ){ secondDirection = directionStringSymmetry( secondDirection, symmetry ); }        secondDirection = motionDirectionTable[ secondDirection ];        if ( !secondDirection ) { secondDirection = direction; }        this.axis.lerpVectors( direction, secondDirection, 0.5 );        this.axis.normalize();        if( this.axis.lengthSq() < 0.0001 ){ this.axis.copy( direction ); }        // angle computations        let startAngle = isNaN( bml.startAngle ) ? 0 : ( bml.startAngle * Math.PI / 180.0 );        let endAngle = isNaN( bml.endAngle ) ? ( startAngle + 2 * Math.PI ) : ( bml.endAngle * Math.PI / 180.0 );        this.targetDeltaAngle = endAngle - startAngle;        if( symmetry ){ // startAngle does not need to change. EndAngle is no longer used            this.targetDeltaAngle *= -1;        }               // rotate starting point from default plane (xy) to the user's specified (given by axis)        _tempVec3_0.set(0,0,1);        // default axis        let dot = _tempVec3_0.dot( direction );        if ( dot > 0.999 ){ _tempQuat_0.set(0,0,0,1); }        else if ( dot < -0.999 ){ _tempVec3_0.set(0,1,0); _tempQuat_0.setFromAxisAngle( _tempVec3_0, Math.PI ); }        else{            let angle = _tempVec3_0.angleTo( direction );            _tempVec3_0.crossVectors( _tempVec3_0, direction );            _tempVec3_0.normalize();            _tempQuat_0.setFromAxisAngle( _tempVec3_0, angle );        }        let distance = isNaN( bml.distance ) ? 0.05 : bml.distance;        this.startPoint.set(0,1,0).multiplyScalar( distance );        this.startPoint.applyQuaternion( _tempQuat_0 );        // apply starting angle to startPoint        this.startPoint.applyAxisAngle( this.axis, startAngle );        // zig-zag        let zigzag = motionDirectionTable[ bml.zigzag ];        if ( !zigzag ){            this.zigzagDir.set(0,0,0);            this.zigzagSize = 0.0; // metres            this.zigzagSpeed = 0; // rps        }else{            this.zigzagDir.copy( zigzag );            this.zigzagSize = isNaN( bml.zigzagSize ) ? 0.01 : bml.zigzagSize; // metres            this.zigzagSpeed = isNaN( bml.zigzagSpeed ) ? 2 : bml.zigzagSpeed; // rps        }        // check and set timings        this.start = bml.start || 0;        this.end = bml.end || (bml.start + 1);        this.attackPeak = bml.attackPeak;        this.relax = bml.relax;        this.time = 0;         // flag to start         this.transition = true;    }}let fingerPlayTable = {    index : new THREE.Quaternion ( 0.3056621,  0.0039430, -0.0053422, 0.9521169 ),    middle: new THREE.Quaternion ( 0.3522030,  0.0105015, -0.0046960, 0.9358529 ),    ring  : new THREE.Quaternion ( 0.2910635,  0.0143004,  0.0083483, 0.9565603 ),    pinky : new THREE.Quaternion ( 0.2807940, -0.0096333,  0.0081887, 0.9596847 ),}class FingerPlay {    constructor(){         this.index = new THREE.Quaternion(0,0,0,1);        this.middle = new THREE.Quaternion(0,0,0,1);        this.ring = new THREE.Quaternion(0,0,0,1);        this.pinky = new THREE.Quaternion(0,0,0,1);        this.fingerEnabler = 0x00; // flags. bit0 = thumb, bit1 = index, bit2 = middle, bit3 = ring, bit4 = pinky                this.transition = false;        this.time = 0;        this.speed = 3;        this.intensity = 0.3;        this.start = 0;        this.attackPeak = 0;        this.relax = 0;        this.end = 0;    }    reset(){        this.transition = false;        this.index.set(0,0,0,1);        this.middle.set(0,0,0,1);        this.ring.set(0,0,0,1);        this.pinky.set(0,0,0,1);    }    update( dt ){        if ( !this.transition ){ return; }        this.time += dt;        let intensity = 0;        if ( this.time < this.start ){ intensity = 0; }        else if ( this.time < this.attackPeak ){ intensity = ( this.time - this.start ) / ( this.attackPeak - this.start ); }        else if ( this.time < this.relax ){ intensity = 1; }        else if ( this.time < this.end ){ intensity = ( this.time - this.relax ) / ( this.end - this.relax ); intensity = 1.0-intensity; }        else {            intensity = 0;             this.transition = false;        }        intensity *= this.intensity;        // 2 t: entry T, interpolation t         // interpolatino -- cos(t + X) where is different for each finger        if ( this.fingerEnabler & 0x02 ) {             this.index.identity();            nlerpQuats( this.index, this.index, fingerPlayTable.index,    ( Math.cos( Math.PI * 2 * this.speed * this.time ) * 0.5 + 0.5 ) * intensity );        }        if ( this.fingerEnabler & 0x04 ) {             this.middle.identity();            nlerpQuats( this.middle, this.middle, fingerPlayTable.middle, ( Math.cos( Math.PI * 2 * this.speed * this.time + Math.PI * 0.65 ) * 0.5 + 0.5 ) * intensity * 0.9);        }        if ( this.fingerEnabler & 0x08 ) {             this.ring.identity();            nlerpQuats( this.ring, this.ring, fingerPlayTable.ring,       ( Math.cos( Math.PI * 2 * this.speed * this.time + Math.PI * 1.05 ) * 0.5 + 0.5 ) * intensity * 0.7 );        }        if ( this.fingerEnabler & 0x10 ) {             this.pinky.identity();            nlerpQuats( this.pinky, this.pinky, fingerPlayTable.pinky,    ( Math.cos( Math.PI * 2 * this.speed * this.time + Math.PI * 1.35 ) * 0.5 + 0.5 ) * intensity * 0.5 );        }    }     /**     * bml info     * start, attackPeak, relax, end     * speed = (optional) oscillations per second. Default 3     * intensity = (optional) [0,1]. Default 0.3     * fingers = (optional) string with numbers. Each number present activates a finger. 1=index, 2=middle, 3=ring, 4=pinky. I.E. "123" activates index, middle, ring but not pinky. Default all enabled     */    newGestureBML( bml ){        this.speed = isNaN( bml.speed ) ? 3 : bml.speed;        this.intensity = isNaN( bml.intensity ) ? 0.3 : bml.intensity;        this.intensity = Math.min( 1, Math.max( 0, this.intensity ) );        this.transition = true;        this.fingerEnabler = 0x1f;        if ( typeof( bml.fingers ) == 'string' ){            // enable only the specified fingers (bits)            this.fingerEnabler = 0x00;             for( let i = 0; i < bml.fingers.length; ++i ){                let val = parseInt( bml.fingers[i] );                if ( !isNaN( val ) ){ this.fingerEnabler |= 0x01 << val; }            }            this.fingerEnabler &= 0x1f; // mask unused bits        }        // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;     }};class WristMotion {    constructor( wristBone ){        this.wristBone = wristBone;                this.mode = 0; // FLAGS 0=NONE, 1=TWIST, 2=NOD, 4=SWING         this.intensity = 1;        this.speed = 1;        this.time = 0;        this.start = 0;        this.attackPeak = 0;        this.relax = 0;        this.end = 0;    }    reset(){        this.time = 0;        this.mode = 0;    }    update( dt ){        if ( !this.mode ){ return; }        this.time += dt;        let intensity = 0;        if ( this.time < this.start ){ intensity = 0; }        else if ( this.time < this.attackPeak ){ intensity = ( this.time - this.start ) / ( this.attackPeak - this.start ); }        else if ( this.time < this.relax ){ intensity = 1; }        else if ( this.time < this.end ){ intensity = ( this.time - this.relax ) / ( this.end - this.relax ); intensity = 1.0-intensity; }        else {            intensity = 0;             this.mode = 0x00; // tansition = false        }        intensity *= this.intensity;        if ( this.mode & 0x01 ){ // TWIST            let twistAxis = _tempVec3_0;            twistAxis.set(0,0,1);            twistAxis.applyQuaternion( this.wristBone.quaternion );            let angle = Math.cos( 2 * Math.PI * this.speed * this.time ) * intensity * ( Math.PI * 0.5 );            _tempQuat_0.setFromAxisAngle( twistAxis, angle );            this.wristBone.quaternion.premultiply( _tempQuat_0 );        }        if ( this.mode & 0x02 ){ // NOD            let nodAxis = _tempVec3_0;            nodAxis.set(1,0,0);            nodAxis.applyQuaternion( this.wristBone.quaternion );            let angle = Math.cos( 2 * Math.PI * this.speed * this.time ) * intensity * ( Math.PI * 0.5 );            _tempQuat_0.setFromAxisAngle( nodAxis, angle );            this.wristBone.quaternion.premultiply( _tempQuat_0 );        }        if ( this.mode & 0x04 ){ // SWING            let swingAxis = _tempVec3_0;            swingAxis.set(0,1,0);            swingAxis.applyQuaternion( this.wristBone.quaternion );            let angle = Math.sin( 2 * Math.PI * this.speed * this.time ) * intensity * ( Math.PI * 0.5 ); // PHASE of 90ª with respect to NOD (see newGestureBML)            _tempQuat_0.setFromAxisAngle( swingAxis, angle );            this.wristBone.quaternion.premultiply( _tempQuat_0 );        }    }     /**     * bml info     * start, attackPeak, relax, end     * mode = either a:      *          - string from [ "nod", "nodding", "swing", "swinging", "twist", "twisting", "stirCW", "stircw", "stirCCW", "stirccw", "all" ]     *          - or a value from [ 0 = None, 1 = twist, 2 = nod, swing = 4 ].      *            Several values can co-occur by using the OR (|) operator. I.E. ( 2 | 4 ) = stirCW     *            Several values can co-occur by summing the values. I.E. ( 2 + 4 ) = stirCW     * speed = (optional) oscillations per second. A negative values accepted. Default 3.      * intensity = (optional) [0,1]. Default 0.3     */    newGestureBML( bml ){                this.speed = isNaN( bml.speed ) ? 3 : bml.speed;        this.intensity = isNaN( bml.intensity ) ? 0.3 : bml.intensity;        this.intensity = Math.min( 1, Math.max( 0, this.intensity ) );                if ( typeof( bml.mode ) == "string" ){            switch( bml.mode ){                case "nod": case "nodding": this.mode = 0x02; break;                case "swing": case "swinging": this.mode = 0x04; break;                case "twist": case "twisting": this.mode = 0x01; break;                case "stirCW": case "stircw": this.mode = 0x06; break; // 0x02 | 0x04                case "stirCCW": case "stirccw":this.mode = 0x06; this.speed *= -1; break;                case "all": this.mode = 0x07; break;                default:                    console.warn( "Gesture: No wrist motion called \"", bml.mode, "\" found" );                    return;            }        }        else if ( isNaN( bml.mode ) ) {            console.warn( "Gesture: No wrist motion called \"", bml.mode, "\" found" );            return;        }        else{            this.mode = bml.mode & 0x07; // take only the necessary bits        }                // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;     }};    
// convert rotation names into radiants. Using positive/negative angles helps with correct interpolation pathlet palmorRightTable = {    'ur': 225 * Math.PI / 180,    'u' : 180 * Math.PI / 180,     'ul': 135 * Math.PI / 180,    'l' : 90 * Math.PI / 180,    'dl': 45 * Math.PI / 180,    'd' : 0 * Math.PI / 180,    'dr': -45 * Math.PI / 180,    'r' : -90 * Math.PI / 180,}let palmorLeftTable = {    'l' : 90 * Math.PI / 180,    'dl': 45 * Math.PI / 180,    'd' : 0 * Math.PI / 180,    'dr': -45 * Math.PI / 180,    'r' : -90 * Math.PI / 180,    'ur': -135 * Math.PI / 180,    'u' : -180 * Math.PI / 180,     'ul': -225 * Math.PI / 180,}// receives bml instructions and animates the handsclass Palmor {    constructor( boneMap, skeleton, isLeftHand = false ){        this.skeleton = skeleton;        this.mirror = !!isLeftHand;                let handName = ( isLeftHand ) ? "L" : "R";        let bones = this.skeleton.bones;        this.idx = boneMap[ handName + "Elbow" ]; // elbow (forearm) joint index.         // handName = "R";        this.twistAxisForeArm = ( new THREE.Vector3() ).copy( bones[ boneMap[ handName + "Wrist"] ].position ).normalize(); // position is already local to ForeArm bone        this.twistAxisWrist =  ( new THREE.Vector3() ).copy( bones[ boneMap[ handName + "HandMiddle"] ].position ).normalize(); // position is already local to Wrist bone                        // store TWIST quaternions for forearm and hand (visally better than just forearm or wrist)        this.defAngle = 0;        this.trgAngle = 0;        this.srcAngle = 0;        this.curAngle = 0;        this.time = 0; // current time of transition        this.start = 0;        this.attackPeak = 0;        this.relax = 0;         this.end = 0;        this.transition = false;                // set default pose        this.reset();    }    reset() {        // Force pose update to flat        this.transition = false;        this.defAngle = 0;        this.curAngle = 0;    }    update( dt ) {        if ( !this.transition ){ return; } // no animation required                this.time += dt;        // wait in same pose        if ( this.time < this.start ){ return; }        if ( this.time > this.attackPeak && this.time < this.relax ){             this.curAngle = this.trgAngle;            return;         }                if ( this.time <= this.attackPeak ){            let t = ( this.time - this.start ) / ( this.attackPeak - this.start );            if ( t > 1 ){ t = 1; }            t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;            this.curAngle = this.srcAngle * ( 1 - t ) + this.trgAngle * t;            return;        }        if ( this.time >= this.relax ){            let t = ( this.time - this.relax ) / ( this.end - this.relax );            if ( t > 1 ){ t = 1; }            t = Math.sin(Math.PI * t - Math.PI * 0.5) * 0.5 + 0.5;            this.curAngle = this.trgAngle * ( 1 - t ) + this.defAngle * t;        }                if ( this.time > this.end ){             this.transition = false;        }    }    /**     * bml info     * start, attackPeak, relax, end     * palmor: string from palmorRightTable     */    newGestureBML( bml, symmetry = 0x00 ){        if( !bml.palmor ){ return; }        let rotationName = bml.palmor;        let secondRotName = bml.secondPalmor;        if ( rotationName && symmetry ){ rotationName = directionStringSymmetry( rotationName, symmetry ); }        if ( secondRotName && symmetry ){ secondRotName = directionStringSymmetry( secondRotName, symmetry ); }                let angle = ( this.mirror ) ? palmorLeftTable[ rotationName ] : palmorRightTable[ rotationName ];        if( isNaN( angle ) ){ return; }        let secondAngle = ( this.mirror ) ? palmorLeftTable[ secondRotName ] : palmorRightTable[ secondRotName ];        if( !isNaN( secondAngle ) ){             // find shortest path in the circle and adjust secondAngle            if( Math.abs(angle - secondAngle) > Math.PI ){                if( ( angle - secondAngle ) < 0 ){ secondAngle -= 2 * Math.PI; }                else{ secondAngle += 2 * Math.PI; }            }            // avoid impossible angles            if( this.mirror ){ secondAngle = Math.max( palmorLeftTable['ul'], Math.min( palmorRightTable['l'], secondAngle ) ); }            else{ secondAngle = Math.max( palmorLeftTable['ur'], Math.min( palmorRightTable['u'], secondAngle ) ); }            angle = 0.5 * angle + 0.5 * secondAngle;         }                // set source pose twist quaternions        this.srcAngle = this.curAngle;         // set target pose        this.trgAngle = angle;        // set defualt pose if necessary        if ( bml.shift ){            this.defAngle = this.trgAngle;        }        // check and set timings        this.start = bml.start || 0;        this.end = bml.end || bml.relax || bml.attackPeak || (bml.start + 1);        this.attackPeak = bml.attackPeak || ( (this.end - this.start) * 0.25 + this.start );        this.relax = bml.relax || ( (this.end - this.attackPeak) * 0.5 + this.attackPeak );        this.time = 0;                 this.transition = true;    }}
function quadraticBezierVec3( a, b, c, out, t ){    let invT = 1.0 - t;    let ta = invT * invT;    let tb = 2 * t * invT;    let tc = t * t;    out.x = a.x * ta + b.x * tb + c.x * tc;    out.y = a.y * ta + b.y * tb + c.y * tc;    out.z = a.z * ta + b.z * tb + c.z * tc;    return out;}function cubicBezierVec3( a, b, c, d, out, t ){    let invT = 1.0 - t;    let ta = invT * invT * invT;    let tb = 3 * t * invT * invT;    let tc = 3 * t * t * invT;    let td = t * t * t;    out.x = a.x * ta + b.x * tb + c.x * tc + d.x * td;    out.y = a.y * ta + b.y * tb + c.y * tc + d.y * td;    out.z = a.z * ta + b.z * tb + c.z * tc + d.z * td;    return out;}// ------------ THREEJS Quaternions// mirror THREE.Quaternion for avatarsfunction mirrorQuat( destQuat, srcQuat ){    //destQuat.x = srcQuat.x;    destQuat.y = -srcQuat.y;    destQuat.z = -srcQuat.z;    //destQuat.w = srcQuat.w;}function mirrorQuatSelf( q ){    //q.x = -q.x;    q.y = -q.y;    q.z = -q.z;    //q.w = q.w;}// nlerp THREE.Quaternion. Good for interpolation between similar/close quaternions. Cheaper than slerp but might interpolate through the wrong/weird path. Use slerp (more expensive but finds shortest path)function nlerpQuats( destQuat, qa, qb, t ){    destQuat.x = qa.x * (1-t) + qb.x * t;    destQuat.y = qa.y * (1-t) + qb.y * t;    destQuat.z = qa.z * (1-t) + qb.z * t;    destQuat.w = qa.w * (1-t) + qb.w * t;    destQuat.normalize();}// decompose a quaternion into twist and swing quaternions. (Twist before swing decomposition). Arguments cannot be the same instance of quaternionfunction twistSwingQuats( q, normAxis, outTwist, outSwing ){    //  R = [ Wr, Vr ] = S * T  source rotation    // T = norm( [ Wr, proj(Vr) ] ) twist     // S = R * inv(T)    let dot =  q.x * normAxis.x + q.y * normAxis.y + q.z * normAxis.z;    outTwist.set( dot * normAxis.x, dot * normAxis.y, dot * normAxis.z, q.w )    outTwist.normalize(); // already manages (0,0,0,0) quaternions by setting identity    outSwing.copy( outTwist );    outSwing.invert(); // actually computes the conjugate so quite cheap    outSwing.premultiply( q );    outSwing.normalize();}// symmetry stringfunction directionStringSymmetry( str, flags ){    let result = str;    if ( flags & 0x01 ){ // left-right symmetry        if ( result.includes( "l" ) ){ result = result.replace( "l", "r" ); }         else if( result.includes( "r" ) ){ result =result.replace( "r", "l" ); }    }    if ( flags & 0x02 ){ // up-down symmetry        if ( result.includes( "u" ) ){ result = result.replace( "u", "d" ); }         else if( result.includes( "d" ) ){ result =result.replace( "d", "u" ); }    }    if ( flags & 0x04 ){ // in-out symmetry        if ( result.includes( "i" ) ){ result = result.replace( "i", "o" ); }         else if( result.includes( "o" ) ){ result =result.replace( "o", "i" ); }    }    return result;}// Skeleton// O(n)function findIndexOfBone( skeleton, name ){    let b = skeleton.bones;    for( let i = 0; i < b.length; ++i ){        if ( b[i].name == name ){ return i; }    }    return -1;}
export { BehaviourManager, BehaviourPlanner, Blink, FacialExpr, FacialEmotion, GazeManager, Gaze, HeadBML, Lipsync, Text2LipInterface, T2LTABLES, Extfidir, extfidirPointTable, HandShapeRealizer, LocationArmIK, nearArmPosesTable, DirectedMotion, CircularMotion, FingerPlay, WristMotion, Palmor, quadraticBezierVec3, cubicBezierVec3, mirrorQuat, mirrorQuatSelf, nlerpQuats, twistSwingQuats, directionStringSymmetry, findIndexOfBone} 
