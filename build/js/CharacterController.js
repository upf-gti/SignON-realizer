import { BehaviourPlanner, BehaviourManager, Blink, FacialExpr, FacialEmotion, GazeManager, Gaze, HeadBML, Lipsync, Text2LipInterface, T2LTABLES, LocationArmIK, Palmor, Extfidir, HandShapeRealizer, CircularMotion, DirectedMotion, FingerPlay, WristMotion, findIndexOfBone } from './BML.js';
import * as THREE  from 'three';
import { CCDIKSolver } from './IKSolver.js';
//@ECA controller//StatesCharacterController.prototype.WAITING = 0;CharacterController.prototype.PROCESSING = 1;CharacterController.prototype.SPEAKING = 2;CharacterController.prototype.LISTENING = 3;window.SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;function CharacterController(o) {    this.time = 0;    this.character = o.character;    if (typeof BehaviourManager !== 'undefined') {        this.BehaviourManager = new BehaviourManager();    }else {        console.error("Manager not included");    }    if (typeof BehaviourPlanner !== 'undefined') {        this.BehaviourPlanner = new BehaviourPlanner();        this.BehaviourPlanner.BehaviourManager = this.BehaviourManager;    } else {        console.error("Planner not included");    }    if (typeof FacialController !== 'undefined') {        this.facialController = new FacialController(o);    } else {        console.error("FacialController module not found");    }    if ( typeof(BodyController) !== 'undefined'){         this.bodyController = new BodyController( this.character );    } }CharacterController.prototype.start = function (o) {    this.pendingResources = [];    this.facialController.start(o);}CharacterController.prototype.reset = function ( keepEmotion = false ) {    this.pendingResources.length = 0;    if ( this.facialController ){         this.facialController.reset( keepEmotion ); }    if (this.BehaviourPlanner){         this.BehaviourPlanner.reset(); }    if (this.BehaviourManager){         this.BehaviourManager.reset(); }    if (this.bodyController){         this.bodyController.reset(); }    this.endSpeakingTime = -1;    this.speaking = false;}CharacterController.prototype.update = function (dt, et) {    let newBlock = null;    this.time = et;    if ( this.facialController ){        this.facialController.update(dt);    }    if (this.BehaviourPlanner){        newBlock = this.BehaviourPlanner.update(dt);    }    if (this.BehaviourManager){        this.BehaviourManager.update(this.processBML.bind(this), et);    }    if (newBlock) {        this.BehaviourManager.newBlock(newBlock, et);    }    if (this.bodyController){        this.bodyController.update(dt)    }    // lipsync stuff????    if (this.BehaviourManager.lgStack.length && this.BehaviourManager.time <= this.BehaviourManager.lgStack[this.BehaviourManager.lgStack.length - 1].endGlobalTime) {        this.endSpeakingTime = this.BehaviourManager.lgStack[this.BehaviourManager.lgStack.length - 1].endGlobalTime + 1        this.speaking = true;    }    else if (this.endSpeakingTime > -1 && this.BehaviourManager.time <= this.endSpeakingTime || this.facialController.lipsyncModule.working) {        this.speaking = true;    }    else {        this.endSpeakingTime = -1;        this.speaking = false;    }}// Process message// Messages can come from inner processes. "fromWS" indicates if a reply to the server is required in BMLManager.jsCharacterController.prototype.processMsg = function (data, fromWS) {    // Update to remove aborted blocks    if (!this.BehaviourManager)        return;    this.BehaviourManager.update(this.processBML.bind(this), this.time);    // Add new block to stack    //this.BehaviourManager.newBlock(msg, thiscene.time);    data = JSON.parse(data);    if (data.type == "behaviours") data = data.data;    // Add new blocks to stack    let msg = {};    if (data.constructor == Array) {        // start and end times of whole message        let end = -1000000;        let start = 1000000;        for (let i = 0; i < data.length; i++) {            if (data[i].type == "info")                continue;            // data based on duration. Fix timings from increments to timestamps            if (!data[i].end && data[i].duration) {                data[i].end = data[i].start + data[i].duration;                if (data[i].attackPeak) data[i].attackPeak += data[i].start;                if (data[i].ready) data[i].ready += data[i].start;                if (data[i].strokeStart) data[i].strokeStart += data[i].start;                if (data[i].stroke) data[i].stroke += data[i].start;                if (data[i].strokeEnd) data[i].strokeEnd += data[i].start;                if (data[i].relax) data[i].relax += data[i].start;            }            // include data of type into msg            if (!msg[data[i].type]) {                msg[data[i].type] = [];            }            msg[data[i].type].push(data[i]);            // update start-end of msg            if (data[i].end > end) end = data[i].end;            if (data[i].start < start) start = data[i].start;        }        msg.start = start;        msg.end = end;        if (!msg.composition)            msg.composition = "MERGE";        if ( msg.speech ) {            msg.control = this.SPEAKING;        }        // Process block        // manages transitions if necessary        if (this.BehaviourPlanner) {            this.BehaviourPlanner.newBlock(msg);        }        // add blocks to stacks        this.BehaviourManager.newBlock(msg, this.time);    }    else if (data.constructor == Object) {        msg = data;        if ( (data.type == "state" || data.type == "control") && data.parameters) {            msg.control = this[data.parameters.state.toUpperCase()];        }        else if (data.type == "info")            return;        if ( msg.speech ) {            msg.control = this.SPEAKING;        }        // Process block        // manages transitions if necessary        if (this.BehaviourPlanner) {            this.BehaviourPlanner.newBlock(msg);        }        // add blocks to stacks        this.BehaviourManager.newBlock(msg, this.time);     }    if (fromWS)        msg.fromWS = fromWS;    // Client id -> should be characterId?    if (msg.clientId && !this.ws.id) {        this.ws.id = msg.clientId;        console.log("Client ID: ", msg.clientId);        return;    }    // Load audio files    if (msg.lg) {        let hasToLoad = this.loadAudio(msg);        if (hasToLoad) {            this.pendingResources.push(msg);            console.log("Needs to preload audio files.");            return;        }    }    if (!msg) {        console.error("An undefined msg has been received.", msg);        return;    }    // Update to remove aborted blocks    if (!this.BehaviourManager)        return;    this.BehaviourManager.update(this.processBML.bind(this), this.time);    if (!msg) {        console.error("An undefined block has been created due to the update of BMLManager.", msg);        return;    }}// Process messageCharacterController.prototype.processBML = function (key, bml) {    if (!this.facialController)        return;    let thatFacial = this.facialController;    switch (key) {        case "blink":            thatFacial.newBlink(bml);            break;        case "gaze":            thatFacial.newGaze(bml, !!bml.shift); // !!shift make it bool (just in case)            break;        case "gazeShift":            thatFacial.newGaze(bml, true);            break;        case "head":            thatFacial.newHeadBML(bml);            break;        case "headDirectionShift":            thatFacial.headDirectionShift(bml);            break;        case "face":            thatFacial.newFA(bml, !!bml.shift); // !!shift make it bool (just in case)            break;        case "faceLexeme":            thatFacial.newFA(bml, !!bml.shift); // !!shift make it bool (just in case)            break;        case "faceFACS":            thatFacial.newFA(bml, false);            break;        case "faceEmotion":            thatFacial.newFA(bml, !!bml.shift); // !!shift make it bool (just in case)            break;        case "faceVA":            thatFacial.newFA(bml, !!bml.shift); // !!shift make it bool (just in case)            break;        case "faceShift":            thatFacial.newFA(bml, true);            break;        case "speech":            if (bml.phT)                bml.phT = new Float32Array(Object.values(bml.phT));            thatFacial.newTextToLip(bml);            break;        case "gesture":            this.bodyController.newGesture( bml );            break;        case "animation":            // TODO            break;        case "lg":            thatFacial.newLipsync( bml );            break;    }}// Preloads audios to avoid loading time when added to BML stacksCharacterController.prototype.loadAudio = function (block) {    let output = false;    if (block.lg.constructor === Array) {        for (let i = 0; i < block.lg.length; i++) {        if (!block.lg[i].audio) {            block.lg[i].audio = new Audio();            block.lg[i].audio.src = block.lg[i].url;            output = true;        }        }    }    else {        if (!block.lg.audio) {            block.lg.audio = new Audio();            block.lg.audio.src = block.lg.url;            output = true;        }    }    return output;}
//@FacialControllerfunction FacialController(config = null) {        // define some properties    this.headNode = "mixamorig_Head";    this.neckNode = "mixamorig_Neck";    this.lookAt = "target";    this.lookAtEyes = "eyesTarget";    this.lookAtHead = "headTarget";    this.lookAtNeck = "neckTarget";    this._gazePositions = {        "RIGHT": new THREE.Vector3(30, 2, 100), "LEFT": new THREE.Vector3(-30, 2, 100),        "UP": new THREE.Vector3(0, 20, 100), "DOWN": new THREE.Vector3(0, -20, 100),        "UPRIGHT": new THREE.Vector3(30, 20, 100), "UPLEFT": new THREE.Vector3(-30, 20, 100),        "DOWNRIGHT": new THREE.Vector3(30, -20, 100), "DOWNLEFT": new THREE.Vector3(-30, -20, 100),        "FRONT": new THREE.Vector3(0, 2, 100), "CAMERA": new THREE.Vector3(0, 2, 100)    };    this.squintBSName = "Squint";    this.eyelidsBSName = "Blink";    this.smileBSName = "Smile";    this.sadBSName = "Sad";    this.kissBSName = "MouthWhistle";    this.lipsPressedBSName = "Jaw_Up";    this.lowerLipINBSName = "LowerLipIn";    this.lowerLipDownBSName = "LowerLipDown";    this.mouthNarrowBSName = "MouthNarrow";    this.mouthOpenBSName = "MouthOpen";    this.tongueBSName = "Tongue";    this.browsDownBSName = "BrowsDown";    this.browsInnerUpBSName = "BrowsIn";    this.browsUpBSName = "BrowsUp";    this._morphDeformers = {};    this.lipsyncModule = new Lipsync();    // if we have the state passed, then we restore the state    if (config)        this.configure(config);}FacialController.prototype.configure = function (o) {    if (o.character)        this.character = o.character;    if (o.headNode)        this.headNode = o.headNode;    if (o.lookAt)        this.lookAt = o.lookAt;    if (o.lookAtEyes)        this.lookAtEyes = o.lookAtEyes;    if (o.lookAtHead)        this.lookAtHead = o.lookAtHead;    if (o.lookAtNeck)        this.lookAtNeck = o.lookAtNeck;    if (o.gazePositions)        this._gazePositions = o.gazePositions;    if (o.morphTargets)        this._morphDeformers = o.morphTargets;}FacialController.prototype.start = function (morphTargets) {       if (!morphTargets) {        // Get morph targets        morphTargets = {            Body: this.character.getObjectByName("BodyMesh") || this.character.getObjectByName("Body"),            Eyelashes: this.character.getObjectByName("Eyelashes")        }    }    this._facialBSAcc = {};    this._facialBSFinal = {};    this._morphDeformers = { "Body": morphTargets.Body, "Eyelashes": morphTargets.Eyelashes };    this._facialBS = {};    this._eyeLidsBS = [];    this._squintBS = [];    if (morphTargets) {        for (let part in this._morphDeformers) {            let eyelidsIdx = [];            let squintIdx = [];            this._facialBS[part] = this._morphDeformers[part].morphTargetInfluences.slice(); // clone array            this._facialBSAcc[part] = this._morphDeformers[part].morphTargetInfluences.slice(); // clone array;            this._facialBSFinal[part] = this._morphDeformers[part].morphTargetInfluences.slice(); // clone array;            let BSnames = Object.keys(this._morphDeformers[part].morphTargetDictionary);            for (let i = 0; i < BSnames.length; ++i) {                let name = BSnames[i].replaceAll("mesh_morph_", "");                // Eyelashes things                if (name.toLocaleLowerCase().includes(this.eyelidsBSName.toLocaleLowerCase())) // get blendshape indices of eyelids                    eyelidsIdx.push(this._morphDeformers[part].morphTargetDictionary[name]);                if (name.toLocaleLowerCase().includes(this.squintBSName.toLocaleLowerCase())) // get blendshape indices of squint                    squintIdx.push(this._morphDeformers[part].morphTargetDictionary[name]);            }            this._eyeLidsBS.push(eyelidsIdx);            this._squintBS.push(squintIdx);        }    }    if (!this._morphDeformers) {        console.error("Morph deformer not found");        return;    }    this.resetFace();    this._FacialLexemes = [];    this.FA = new FacialEmotion(this._facialBS);    // Gaze    // Get head bone node    if (!this.headNode)        console.error("Head bone node not found with id: ");    else if (!this._gazePositions["HEAD"]) {        let headNode = this.character.getObjectByName(this.headNode)        this._gazePositions["HEAD"] = headNode.getWorldPosition(new THREE.Vector3());    }    // Get lookAt nodes      let lookAtEyesNode = this.character.eyesTarget;    let lookAtNeckNode = this.character.neckTarget;    let lookAtHeadNode = this.character.headTarget;    if (!this.lookAtEyes)        console.error("LookAt Eyes not found");    else if (!this._gazePositions["EYESTARGET"])        this._gazePositions["EYESTARGET"] = lookAtEyesNode.getWorldPosition(new THREE.Vector3());    if (!this.lookAtHead)        console.error("LookAt Head not found");    else if (!this._gazePositions["HEADTARGET"])        this._gazePositions["HEADTARGET"] = lookAtHeadNode.getWorldPosition(new THREE.Vector3());    if (!this.lookAtNeck)        console.error("LookAt Neck not found");    else if (!this._gazePositions["NECKTARGET"])        this._gazePositions["NECKTARGET"] = lookAtNeckNode.getWorldPosition(new THREE.Vector3());    // Gaze manager    this.gazeManager = new GazeManager(lookAtNeckNode, lookAtHeadNode, lookAtEyesNode, this._gazePositions);    this.headBML = []; //null;    this.autoBlink = new Blink();}FacialController.prototype.reset = function ( keepEmotion = false ) {    this.resetFace(); // blendshapes to 0    if (this.textToLip) { this.textToLip.cleanQueueSentences(); }    if (this.lipsyncModule) { this.lipsyncModule.stop(); }    this._FacialLexemes.length = 0;    if ( !keepEmotion ){ this.FA.reset(); }     this.gazeManager.reset();    this.headBML.length = 0;}FacialController.prototype.resetFace = function () {        for (let part in this._facialBS) {        for (let i = 0; i < this._facialBS[part].length; i++) {            this._facialBS[part][i] = 0;            this._facialBSAcc[part][i] = 0;            this._facialBSFinal[part][i] = 0;            this._morphDeformers[part].morphTargetInfluences[i] = 0;        }    }}//example of one method called for ever update eventFacialController.prototype.update = function (dt) {    // Update facial expression    this.faceUpdate(dt);    // Gaze    if (this.gazeManager){        let weights = this.gazeManager.update(dt);        let keys = Object.keys(this._facialBS);        // for each part (body, eyelashes)        for(let i = 0; i < keys.length; ++i ){            // eyelids update            for(let j = 0; j< this._eyeLidsBS[i].length; j++){                         this._facialBS[ keys[i] ][ this._eyeLidsBS[i][j] ] = weights.eyelids;            }            // squint update            for(let j = 0; j< this._squintBS[i].length; j++){                this._facialBS[keys[i]][this._squintBS[i][j]] = weights.squint;            }        }    }    let lookAtEyes = this.character.eyesTarget.getWorldPosition(new THREE.Vector3());    let lookAtHead = this.character.headTarget.getWorldPosition(new THREE.Vector3());    let lookAtNeck = this.character.headTarget.getWorldPosition(new THREE.Vector3());        this.character.getObjectByName("mixamorig_Neck").lookAt(lookAtNeck);    this.character.getObjectByName("mixamorig_Head").lookAt(lookAtHead);        // HEAD (nod, shake, tilt, tiltleft, tiltright, forward, backward)    let headQuat = this.character.getObjectByName("mixamorig_Head").quaternion; // Not a copy, but a reference    let neckQuat = this.character.getObjectByName("mixamorig_Neck").quaternion; // Not a copy, but a reference    for( let i = 0; i< this.headBML.length; ++i){        let head = this.headBML[i];        if( !head.transition ){            this.headBML.splice(i,1);            --i;            continue;        }        head.update(dt);        if(head.lexeme == "FORWARD" || head.lexeme == "BACKWARD") {            neckQuat.multiply( head.currentStrokeQuat );            headQuat.multiply( head.currentStrokeQuat.invert() );            head.currentStrokeQuat.invert(); // inverting quats is cheap        }         else            headQuat.multiply( head.currentStrokeQuat );    }        this.character.getObjectByName("mixamorig_LeftEye").lookAt(lookAtEyes);    this.character.getObjectByName("mixamorig_RightEye").lookAt(lookAtEyes);    }// Update facial expressionsFacialController.prototype.faceUpdate = function (dt) {        let keys = Object.keys(this._facialBSAcc);    // for each part (body, eyelashes), reset accumulators for biased average    for (let i = 0; i < keys.length; ++i) {        this._facialBSAcc[keys[i]].fill(0);        this._facialBSFinal[keys[i]].fill(0);    }    // Text to lip    if (this.textToLip && this.textToLip.getCompactState() == 0) { // when getCompactState==0 lipsync is working, not paused and has sentences to process        this.textToLip.update(dt);        let t2lBSW = this.textToLip.getBSW(); // reference, not a copy        for (let i = 0; i < this.textToLipBSMapping.length; i++) {            let mapping = this.textToLipBSMapping[i];            let value = Math.min(1, Math.max(-1, t2lBSW[mapping[1]] * mapping[2]));            let index = mapping[0];            // for this model, some blendshapes need to be negative            this._facialBSAcc["Body"][index] += Math.abs(value); // denominator of biased average            this._facialBSFinal["Body"][index] += value * Math.abs(value); // numerator of biased average        }    }    // lipsync    if (this.lipsyncModule && this.lipsyncModule.working) // audio to lip    {        this.lipsyncModule.update(dt);        let facialLexemes = this.lipsyncModule.BSW;        if (facialLexemes) {            let smooth = 0.66;            let BSAcc = this._facialBSAcc["Body"];            let BSFin = this._facialBSFinal["Body"];            let BS = this._morphDeformers["Body"].morphTargetInfluences; // for smoothing purposes            let morphDict = this._morphDeformers["Body"].morphTargetDictionary;            // search every morphTarget to find the proper ones            let names = Object.keys(morphDict);            for (let i = 0; i < names.length; i++) {                let name = names[i];                let bsIdx = morphDict[name];                let value = 0;                if (name.includes(this.mouthOpenBSName))                    value = (1 - smooth) * BS[bsIdx] + smooth * facialLexemes[2];                if (name.includes(this.lowerLipINBSName))                    value = (1 - smooth) * BS[bsIdx] + smooth * facialLexemes[1];                if (name.includes(this.lowerLipDownBSName))                    value = (1 - smooth) * BS[bsIdx] + smooth * facialLexemes[1];                if (name.includes(this.mouthNarrowBSName))                    value = (1 - smooth) * BS[bsIdx] + smooth * facialLexemes[0] * 0.5;                if (name.includes(this.lipsPressedBSName))                    value = (1 - smooth) * BS[bsIdx] + smooth * facialLexemes[1];                BSAcc[bsIdx] += Math.abs(value); // denominator of biased average                BSFin[bsIdx] += value * Math.abs(value); // numerator of biased average            }        }    }    //FacialEmotion ValAro/Emotions    this.FA.updateVABSW(dt);    for (let j = 0; j < this.FA.currentVABSW.length; j++) {        let value = this.FA.currentVABSW[j];        this._facialBSAcc["Body"][j] += Math.abs(value); // denominator of biased average        this._facialBSFinal["Body"][j] += value * Math.abs(value); // numerator of biased average    }    // FacialExpr lexemes    for (let k = 0; k < this._FacialLexemes.length; k++) {        let lexeme = this._FacialLexemes[k];        if (lexeme.transition) {            lexeme.updateLexemesBSW(dt);            // accumulate blendshape values            for (let i = 0; i < lexeme.indicesLex.length; i++) {                for (let j = 0; j < lexeme.indicesLex[i].length; j++) {                    let value = lexeme.currentLexBSW[i][j];                    let index = lexeme.indicesLex[i][j];                    this._facialBSAcc["Body"][index] += Math.abs(value); // denominator of biased average                    this._facialBSFinal["Body"][index] += value * Math.abs(value); // numerator of biased average                }            }        }        // remove lexeme if finished        if (!lexeme.transition) {            this._FacialLexemes.splice(k, 1);            --k;        }    }    // Second pass, compute mean (division)    // result = ( val1 * |val1|/|sumVals| ) + ( val2 * |val2|/|sumVals| ) + ...    // copy blendshape arrays back to real arrays and compute biased average      let target = this._facialBS["Body"];    let numerator = this._facialBSFinal["Body"];    let acc = this._facialBSAcc["Body"];    for (let i = 0; i < target.length; ++i) {        if (acc[i] < 0.0001) { target[i] = 0; }        else { target[i] = numerator[i] / acc[i]; }    }    // --- UPDATE POST BIASED AVERAGE ---     // this._facialBS has all the valid values    // Eye blink    if (!this.autoBlink.between) {        this.autoBlink.update(dt, this._facialBS["Body"][this._eyeLidsBS[0][0]], this._facialBS["Body"][this._eyeLidsBS[0][1]]);        this._facialBS["Body"][this._eyeLidsBS[0][0]] = this.autoBlink.weights[0];        this._facialBS["Body"][this._eyeLidsBS[0][1]] = this.autoBlink.weights[1];    }    // fix eyelashes after all facial is done    for (let i = 0; i < this._eyeLidsBS[0].length; i++) {        this._facialBS["Eyelashes"][this._eyeLidsBS[1][i]] = this._facialBS["Body"][this._eyeLidsBS[0][i]];    }    for (let i = 0; i < this._squintBS[0].length; i++) {        this._facialBS["Eyelashes"][this._squintBS[1][i]] = this._facialBS["Body"][this._squintBS[0][i]];    }    // "Render" final facial (body && eyelashes) blendshapes    // copy blendshape arrays back to real arrays     for (let part in this._morphDeformers) {        let target = this._morphDeformers[part].morphTargetInfluences;        let source = this._facialBS[part];        for (let i = 0; i < target.length; ++i) {            target[i] = source[i];        }    }}// ----------------------- TEXT TO LIP --------------------// Create a Text to Lip mouthingFacialController.prototype.newTextToLip = function (bml) {        if (!this.textToLip) { // setup        this.textToLip = new Text2LipInterface();        this.textToLip.start(); // keep started but idle        this.textToLipBSMapping = []; // array of [ MeshBSIndex, T2Lindex, factor ]        let BS = Object.keys(this._morphDeformers["Body"].morphTargetDictionary);        let t2lBSWMap = T2LTABLES.BlendshapeMapping;        // determine which blendshapes exist and map them to text2lip output        for(let i = 0; i<BS.length; i++) {            if(BS[i].includes("Midmouth_Left"))         this.textToLipBSMapping.push([ i, t2lBSWMap.kiss, 0.4 ]);            if(BS[i].includes("Midmouth_Right"))        this.textToLipBSMapping.push([ i, t2lBSWMap.kiss, 0.4 ]);            if(BS[i].includes("MouthNarrow_Left"))      this.textToLipBSMapping.push([ i, t2lBSWMap.kiss, 1.0 ]);            if(BS[i].includes("MouthNarrow_Right"))     this.textToLipBSMapping.push([ i, t2lBSWMap.kiss, 1.0 ]);                        if (BS[i].includes("MouthDown"))            this.textToLipBSMapping.push([i, t2lBSWMap.upperLipClosed, 0.4]);            if (BS[i].includes("UpperLipOut"))          this.textToLipBSMapping.push([i, t2lBSWMap.upperLipClosed, -1.5]);            if (BS[i].includes("UpperLipUp_Left"))      this.textToLipBSMapping.push([i, t2lBSWMap.upperLipClosed, -0.3]);            if (BS[i].includes("UpperLipUp_Right"))     this.textToLipBSMapping.push([i, t2lBSWMap.upperLipClosed, -0.3]);            if (BS[i].includes("LowerLipDown_Left"))    this.textToLipBSMapping.push([i, t2lBSWMap.lowerLipClosed, -0.8]);            if (BS[i].includes("LowerLipDown_Right"))   this.textToLipBSMapping.push([i, t2lBSWMap.lowerLipClosed, -0.8]);            if (BS[i].includes("LowerLipIn"))           this.textToLipBSMapping.push([i, t2lBSWMap.lowerLipClosed, 1.0]);            if (BS[i].includes("MouthOpen"))            this.textToLipBSMapping.push([i, t2lBSWMap.jawOpen, 1.0]);            if (BS[i].includes("TongueBackUp"))         this.textToLipBSMapping.push([i, t2lBSWMap.tongueBackUp, 1.0]);            if (BS[i].includes("TongueUp"))             this.textToLipBSMapping.push([i, t2lBSWMap.tongueFrontUp, 1.0]);            if (BS[i].includes("TongueOut"))            this.textToLipBSMapping.push([i, t2lBSWMap.tongueOut, 1.0]);        }    }    this.textToLip.cleanQueueSentences();    this.textToLip.pushSentence(bml.text, bml); // use info object as options container also  }// --------------------- lipsync --------------------------------// Create a Text to Lip mouthingFacialController.prototype.newLipsync = function (bml) {        if (!this.lipsyncModule)        return;    if (bml.audio)        this.lipsyncModule.loadBlob(bml.audio);    else if (bml.url)        this.lipsyncModule.loadSample(bml.url);}// --------------------- FACIAL EXPRESSIONS ---------------------// BML// <face or faceShift start attackPeak relax* end* valaro// <faceLexeme start attackPeak relax* end* lexeme amount// <faceFacs not implemented>// lexeme  [OBLIQUE_BROWS, RAISE_BROWS,//      RAISE_LEFT_BROW, RAISE_RIGHT_BROW,LOWER_BROWS, LOWER_LEFT_BROW,//      LOWER_RIGHT_BROW, LOWER_MOUTH_CORNERS,//      LOWER_LEFT_MOUTH_CORNER,//      LOWER_RIGHT_MOUTH_CORNER,//      RAISE_MOUTH_CORNERS,//      RAISE_RIGHT_MOUTH_CORNER,//      RAISE_LEFT_MOUTH_CORNER, OPEN_MOUTH,//      OPEN_LIPS, WIDEN_EYES, CLOSE_EYES]//// face/faceShift can contain several sons of type faceLexeme without sync attr// valaro Range [-1, 1]// Declare new facial expressionFacialController.prototype.newFA = function (faceData, shift) {        // Use BSW of the agent    for (let morph in this._facialBS) {        for (let i = 0; i < this._facialBS[morph].length; i++) {            this._facialBS[morph][i] = this._morphDeformers[morph].morphTargetInfluences[i];        }    }    if (faceData.emotion || faceData.valaro) {        this.FA.initFaceValAro(faceData, shift, this._facialBS); // new FacialExpr (faceData, shift, this._facialBS);    }    else if (faceData.lexeme) {        this._FacialLexemes.push(new FacialExpr(faceData, shift, this._facialBS));    }}// --------------------- BLINK ---------------------FacialController.prototype.newBlink = function ( bml ){    this.autoBlink.blink();}// --------------------- GAZE ---------------------// BML// <gaze or gazeShift start ready* relax* end influence target influence offsetAngle offsetDirection>// influence [EYES, HEAD, NECK, SHOULDER, WAIST, WHOLE, ...]// offsetAngle relative to target// offsetDirection (of offsetAngle) [RIGHT, LEFT, UP, DOWN, UPRIGHT, UPLEFT, DOWNLEFT, DOWNRIGHT]// target [CAMERA, RIGHT, LEFT, UP, DOWN, UPRIGHT, UPLEFT, DOWNLEFT, DOWNRIGHT]// "HEAD" position is added on StartFacialController.prototype.newGaze = function (gazeData, shift, gazePositions = null) {    // TODO: recicle gaze in gazeManager    let keys = Object.keys(this._facialBS);    let blinkW = this._facialBS[keys[0]][0]    let eyelidsW = this._facialBS[keys[0]][this._eyeLidsBS[0][0]]    let squintW = this._facialBS[keys[0]][this._squintBS[0][0]]    gazeData.eyelidsWeight = eyelidsW;    gazeData.squintWeight = squintW;    gazeData.blinkWeight = blinkW;    this.gazeManager.newGaze(gazeData, shift, gazePositions, !!gazeData.headOnly);}// BML// <headDirectionShift start end target>// Uses gazeBMLFacialController.prototype.headDirectionShift = function (headData, cmdId) {        headData.end = headData.end || 2.0;    headData.influence = "HEAD";    this.newGaze(headData, true, null, true);}// --------------------- HEAD ---------------------// BML// <head start ready strokeStart stroke strokeEnd relax end lexeme repetition amount>// lexeme [NOD, SHAKE, TILT, TILTLEFT, TILTRIGHT, FORWARD, BACKWARD]// repetition cancels stroke attr// amount how intense is the head nod? 0 to 1// New head behaviorFacialController.prototype.newHeadBML = function (headData) {        let node = headData.lexeme == "FORWARD" || headData.lexeme == "BACKWARD" ? this.neckNode : this.headNode;    let bone = this.character.getObjectByName(node);    if (bone) {        this.headBML.push(new HeadBML(headData, bone, bone.quaternion.clone()));    }}
// EVERY MODULE WILL WORK WITH THE RIGHT HAND AS DOMINANT class BodyController{    constructor( character ){        this.character = character;        // get skeleton        let skeleton = this.skeleton = null;        character.traverse( o => {            if ( o.isSkinnedMesh ) {                skeleton = this.skeleton = o.skeleton;            }        } );        // ik for arm, shared among all modules        let ikSolver = this.ikSolver = new CCDIKSolver( this.skeleton );        this.ikTarget = { position: new THREE.Vector3(0,0,0) }; // worldposition        this._ikCreateChain( "LeftHand", "LeftArm", "LeftArm" ); // locationIK        this._ikCreateChain( "RightHand", "RightArm", "RightArm" );        this._ikCreateChain( "LeftHand", "LeftShoulder", "LeftShoulder" );        this._ikCreateChain( "RightHand", "RightShoulder", "RightShoulder" );        this.ikSolver.constraintsEnabler = false;        this.ikSolver.setChainEnablerAll(false);        this.ikSolver.setIterations(10);                // name to index map. If model changes, only this map (and ik) names need to be changed        let boneMap = this.boneMap ={            RShoulder:      findIndexOfBone( this.skeleton, "mixamorig_RightShoulder" ),              RArm:           findIndexOfBone( this.skeleton, "mixamorig_RightArm" ),              RElbow:         findIndexOfBone( this.skeleton, "mixamorig_RightForeArm" ),            RWrist:         findIndexOfBone( this.skeleton, "mixamorig_RightHand" ),            RHandThumb:     findIndexOfBone( this.skeleton, "mixamorig_RightHandThumb1" ),            RHandIndex:     findIndexOfBone( this.skeleton, "mixamorig_RightHandIndex1" ),            RHandMiddle:    findIndexOfBone( this.skeleton, "mixamorig_RightHandMiddle1" ),            RHandRing:      findIndexOfBone( this.skeleton, "mixamorig_RightHandRing1" ),            RHandPinky:     findIndexOfBone( this.skeleton, "mixamorig_RightHandPinky1" ),            LShoulder:      findIndexOfBone( this.skeleton, "mixamorig_LeftShoulder" ),            LArm:           findIndexOfBone( this.skeleton, "mixamorig_LeftArm" ),            LElbow:         findIndexOfBone( this.skeleton, "mixamorig_LeftForeArm" ),            LWrist:         findIndexOfBone( this.skeleton, "mixamorig_LeftHand" ),            LHandThumb:     findIndexOfBone( this.skeleton, "mixamorig_LeftHandThumb1" ),            LHandIndex:     findIndexOfBone( this.skeleton, "mixamorig_LeftHandIndex1" ),            LHandMiddle:    findIndexOfBone( this.skeleton, "mixamorig_LeftHandMiddle1" ),            LHandRing:      findIndexOfBone( this.skeleton, "mixamorig_LeftHandRing1" ),            LHandPinky:     findIndexOfBone( this.skeleton, "mixamorig_LeftHandPinky1" ),        }        // -------------- All modules --------------        this.locationUpdateOffset = new THREE.Vector3(0,0,0);        this.right = {            armChain : this.ikSolver.getChain( "RightArm" ),            locationLastFrameQuats : [ new THREE.Quaternion(0,0,0,1), new THREE.Quaternion(0,0,0,1), new THREE.Quaternion(0,0,0,1) ], // Shoulder, arm, elbow            loc : new LocationArmIK( boneMap, skeleton, ikSolver, false ),            locMotions : [],            extfidir : new Extfidir( boneMap, skeleton, false ),            palmor : new Palmor( boneMap, skeleton, false ),            wristMotion : new WristMotion( skeleton.bones[ boneMap["RWrist"] ] ),            handshape : new HandShapeRealizer( boneMap, skeleton, false ),            fingerplay : new FingerPlay()        }        this.left = {            armChain : this.ikSolver.getChain( "LeftArm" ),            locationLastFrameQuats : [ new THREE.Quaternion(0,0,0,1), new THREE.Quaternion(0,0,0,1), new THREE.Quaternion(0,0,0,1) ], // Shoulder, arm, elbow            loc : new LocationArmIK( boneMap, skeleton, ikSolver, true ),            locMotions : [],            extfidir : new Extfidir( boneMap, skeleton, true ),            palmor : new Palmor( boneMap, skeleton, true ),            wristMotion : new WristMotion( skeleton.bones[ boneMap["LWrist"] ] ),            handshape : new HandShapeRealizer( boneMap, skeleton, true ),            fingerplay : new FingerPlay()        }        this.dominant = this.right;        this._tempQ_0 = new THREE.Quaternion();    }    _resetArm( arm ){        arm.loc.reset();        arm.locMotion = [];        arm.extfidir.reset();        arm.palmor.reset();        arm.wristMotion.reset();        arm.handshape.reset();        arm.fingerplay.reset();    }    reset(){        this.locationUpdateOffset.set(0,0,0);        this._resetArm( this.right );        this._resetArm( this.left );        this.newGesture( { type: "gesture", start: 0, end: 0.1, locationArm: "neutral", hand: "right", distance: 0.065, side: "dl", sideDistance: 0.025, shift:true } );        this.newGesture( { type: "gesture", start: 0, end: 0.1, locationArm: "neutral", hand: "left",  distance: 0.04, side: "r", sideDistance: 0.025, shift:true } );        this.newGesture( { type: "gesture", start: 0, end: 0.1, handshape: "flat", thumbshape: "touch", hand: "both", shift:true } );        this.newGesture( { type: "gesture", start: 0, end: 0.1, palmor: "l", hand: "right", shift: true } );        this.newGesture( { type: "gesture", start: 0, end: 0.1, palmor: "r", hand: "left", shift: true } );        this.newGesture( { type: "gesture", start: 0, end: 0.1, extfidir: "dl", hand: "right", mode: "local", shift:true } );        this.newGesture( { type: "gesture", start: 0, end: 0.1, extfidir: "dr", hand: "left", mode: "local", shift:true } );    }    setDominantHand( isRightHandDominant ){        if( isRightHandDominant ){ this.dominant = this.right; }        else{ this.dominant = this.left; }    }    _updateLocationMotions( dt, ikChain, motions ){        this.locationUpdateOffset.set(0,0,0);        let computeFlag = false;        // check if any motion is active and update it        for ( let i = 0; i < motions.length; ++i ){            if ( motions[i].transition ){                computeFlag = true;                this.locationUpdateOffset.add( motions[i].update( dt ) );            }else{                motions.splice(i, 1); // removed motion that has already ended                i--;            }        }        // compute ik only if necessary        if( computeFlag ){            this.skeleton.bones[ ikChain.chain[0] ].getWorldPosition( this.ikTarget.position );            this.ikTarget.position.add( this.locationUpdateOffset );                ikChain.enabler = true;            this.ikSolver.update();            ikChain.enabler = false;        }        }    _updateArm( dt, arm ){        let bones = this.skeleton.bones;        // overwrite arm posture.        arm.loc.update( dt );        for( let i = 0; i < arm.loc.curG.length ; ++i ){             bones[ arm.loc.idx + i ].quaternion.copy( arm.loc.curG[i] );        }        this._updateLocationMotions( dt, arm.armChain, arm.locMotions ); // IK               arm.locationLastFrameQuats[0].copy( bones[ arm.loc.idx ].quaternion );        arm.locationLastFrameQuats[1].copy( bones[ arm.loc.idx + 1 ].quaternion );        arm.locationLastFrameQuats[2].copy( bones[ arm.loc.idx + 2 ].quaternion );        // wrist extfidir        bones[ arm.extfidir.idx ].quaternion.set(0,0,0,1);        arm.extfidir.update( dt );        bones[ arm.extfidir.idx ].quaternion.copy( arm.extfidir.curG );        // wrist (and forearm) twist        arm.palmor.update( dt );        let q = this._tempQ_0;        let palmorAngle = arm.palmor.curAngle * arm.extfidir.curPalmorRefactor        q.setFromAxisAngle( arm.palmor.twistAxisWrist, palmorAngle ); // wrist        bones[ arm.palmor.idx + 1 ].quaternion.multiply( q );        q.setFromAxisAngle( arm.palmor.twistAxisForeArm, 0.65 * palmorAngle + arm.extfidir.foreArmCorrectionAngle ); // forearm twist + correction angle (see extfidir)        bones[ arm.palmor.idx ].quaternion.multiply( q );        q.invert();        bones[ arm.extfidir.idx ].quaternion.premultiply( q ); // this forearm twist is not taken into account in extfidir computation. Adding inverse in wrist counters it         // wristmotion. ADD rotation to wrist        arm.wristMotion.update(dt); // wrist - add rotation        // // overwrite finger rotations        arm.handshape.update( dt );        arm.fingerplay.update(dt); // add finger rotations        bones[ arm.handshape.idxs.index  ].quaternion.premultiply( arm.fingerplay.index );        bones[ arm.handshape.idxs.middle ].quaternion.premultiply( arm.fingerplay.middle );        bones[ arm.handshape.idxs.ring   ].quaternion.premultiply( arm.fingerplay.ring );        bones[ arm.handshape.idxs.pinky  ].quaternion.premultiply( arm.fingerplay.pinky );            }    update( dt ){        this._updateArm( dt, this.right );        this._updateArm( dt, this.left );    }    _newGestureArm( bml, arm, symmetry = 0x00 ){        if ( bml.locationArm ){ // when location change, cut directed and circular motions            arm.loc.newGestureBML( bml, symmetry, arm.locationLastFrameQuats );            arm.locMotions = [];        }        else if ( bml.motion ){            let m = null;            if ( bml.motion == "fingerplay"){ m = arm.fingerplay; }            else if ( bml.motion == "wrist"){ m = arm.wristMotion; }            else if ( bml.motion == "directed"){ m = new DirectedMotion(); arm.locMotions.push(m); }            else if ( bml.motion == "circular"){ m = new CircularMotion(); arm.locMotions.push(m); }                        if( m ){                 m.newGestureBML( bml, symmetry );             }        }        else if ( bml.palmor ){            arm.palmor.newGestureBML( bml, symmetry );        }        else if ( bml.extfidir ){            arm.extfidir.newGestureBML( bml, symmetry );        }        else if ( bml.handshape ){            arm.handshape.newGestureBML( bml, symmetry );        }     }    /**    * lrSym: (optional) bool - perform a symmetric movement. Symmetry will be applied to non-dominant hand only    * udSym: (optional) bool - perform a symmetric movement. Symmetry will be applied to non-dominant hand only    * ioSym: (optional) bool - perform a symmetric movement. Symmetry will be applied to non-dominant hand only    * hand: (optional) "right", "left", "both". Default right    * shift: (optional) bool - make this the default position. Motions not affected    */    newGesture( bml ){        // symmetry: bit0 = lr, bit1 = ud, bit2 = io        let symmetryFlags = ( !!bml.lrSym );        symmetryFlags |= ( ( !!bml.udSym ) << 1 );        symmetryFlags |= ( ( !!bml.ioSym ) << 2 );        if ( bml.dominant ){            this.setDominantHand( bml.dominant == "right" );        }        if ( ( bml.hand == "left" || bml.hand == "both" ) ){             this._newGestureArm( bml, this.left, ( this.dominant != this.left ) ? symmetryFlags : 0x00 );         }        if ( ( bml.hand != "left" ) ){             this._newGestureArm( bml, this.right, ( this.dominant != this.right ) ? symmetryFlags : 0x00 );         }            }    _ikCreateChain( effectorName, rootName, chainName ) {        let bones = this.skeleton.bones;        let effector = this.skeleton.getBoneByName( effectorName );        let root = this.skeleton.getBoneByName( rootName );        if ( !effector ) { // find similarly named bone            for ( let i = 0; i < bones.length; ++i ) {                if ( bones[ i ].name.includes( effectorName ) ) {                    effector = bones[ i ];                    break;                }            }        }        if ( !root ) { // bind similarly named bone            for ( let i = 0; i < bones.length; ++i ) {                if ( bones[ i ].name.includes( rootName ) ) {                    root = bones[ i ];                    break;                }            }        }        if ( !effector || !root ) { return false; }        let chain = []        let bone = effector;        while ( true ) {            let i = bones.indexOf( bone );            if ( i < 0 ) { console.warn( "IK chain: Skeleton root was reached before chain root " ); break; }            chain.push( i );            if ( bone == root ) { break; }            bone = bone.parent;        }        if ( !this.ikSolver.getChain( chainName ) ) {            this.ikSolver.createChain( chain, null, this.ikTarget, chainName );            return true;        }        return false;    }}
export { CharacterController, FacialController, BodyController} 
